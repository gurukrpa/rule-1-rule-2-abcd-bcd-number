// src/components/ABCDBCDNumber.jsx

import React, { useState, useEffect } from 'react';
import { Link, useNavigate, useParams } from 'react-router-dom';
import { supabase } from '../supabaseClient';
import * as XLSX from 'xlsx';
import IndexPage from './IndexPage';
import Rule1Page from './Rule1Page';
import Rule2Page from './Rule2Page';
import Rule2CompactPage from './Rule2CompactPage';
import AddDateModal from './modals/AddDateModal';
import HourEntryModal from './modals/HourEntryModal';
import { DataService } from '../services/dataService';

// 9 planets for dropdowns
const planets = [
  { value: 'Su', label: 'Sun (Su)' },
  { value: 'Mo', label: 'Moon (Mo)' },
  { value: 'Ma', label: 'Mars (Ma)' },
  { value: 'Me', label: 'Mercury (Me)' },
  { value: 'Ju', label: 'Jupiter (Ju)' },
  { value: 'Ve', label: 'Venus (Ve)' },
  { value: 'Sa', label: 'Saturn (Sa)' },
  { value: 'Ra', label: 'Rahu (Ra)' },
  { value: 'Ke', label: 'Ketu (Ke)' }
];

function ABCDBCDNumber() {
  const navigate = useNavigate();
  const { userId } = useParams();
  
  // Initialize DataService for localStorage fallback during migration
  const dataService = new DataService();
  
  const [users, setUsers] = useState([]);
  const [selectedUser, setSelectedUser] = useState('');
  const [selectedDate, setSelectedDate] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [datesList, setDatesList] = useState([]);
  const [showAddDateModal, setShowAddDateModal] = useState(false);
  const [newDate, setNewDate] = useState('');
  const [dateError, setDateError] = useState('');
  const [showHourEntryModal, setShowHourEntryModal] = useState(false);
  const [hourEntryDate, setHourEntryDate] = useState('');
  const [hourEntryPlanetSelections, setHourEntryPlanetSelections] = useState({});
  const [hourEntryError, setHourEntryError] = useState('');
  const [showIndexPage, setShowIndexPage] = useState(false);
  const [indexPageData, setIndexPageData] = useState(null);
  const [showRule1Page, setShowRule1Page] = useState(false);
  const [rule1PageData, setRule1PageData] = useState(null);
  const [showRule2Page, setShowRule2Page] = useState(false);
  const [rule2PageData, setRule2PageData] = useState(null);
  const [dateStatuses, setDateStatuses] = useState({}); // Track Excel/Hour Entry status for each date

  // Fetch users from Supabase or localStorage
  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      setLoading(true);
      const { data: supabaseUsers, error: supabaseError } = await supabase
        .from('users')
        .select('*');

      let processedUsers = [];
      if (!supabaseError && supabaseUsers && supabaseUsers.length > 0) {
        processedUsers = supabaseUsers.map(user => ({
          ...user,
          id: String(user.id),
          hr: Number(user.hr) || 1
        }));
      } else {
        // Fallback to localStorage - still needed for user data as DataService focuses on dates/excel/hour entries
        let stored = localStorage.getItem('abcd_users_data');
        if (stored) {
          try {
            processedUsers = JSON.parse(stored).map(u => ({
              ...u,
              id: String(u.id),
              hr: Number(u.hr) || 1
            }));
          } catch {
            processedUsers = [];
          }
        }
        if (!Array.isArray(processedUsers) || processedUsers.length === 0) {
          processedUsers = [
            { id: '1', username: 'Test User 1', hr: 3 },
            { id: '2', username: 'Test User 2', hr: 4 },
            { id: '3', username: 'Test User 3', hr: 5 }
          ];
          localStorage.setItem('abcd_users_data', JSON.stringify(processedUsers));
        }
      }
      setUsers(processedUsers);
      setError('');
    } catch (err) {
      setError('Failed to fetch users. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Load dates for selected user
  useEffect(() => {
    if (selectedUser) {
      loadUserDates(selectedUser);
    } else {
      setDatesList([]);
      setSelectedDate('');
    }
  }, [selectedUser]);

  const loadUserDates = async (uid) => {
    try {
      console.log('üîÑ [ABCDBCDNumber] loadUserDates called for user:', uid);
      
      // Check deletion flag before loading dates
      const deletionFlag = localStorage.getItem(`abcd_user_deleted_all_${uid}`);
      console.log('üèÅ [ABCDBCDNumber] Deletion flag check:', deletionFlag);
      
      const dates = await dataService.getDates(uid);
      console.log('üìÖ [ABCDBCDNumber] Dates received from DataService:', dates);
      
      if (dates && dates.length > 0) {
        const sorted = dates.sort((a, b) => new Date(b) - new Date(a));
        console.log('‚úÖ [ABCDBCDNumber] Setting dates list:', sorted);
        setDatesList(sorted);
        setSelectedDate(sorted[0]);
        return;
      }
      
      console.log('üì≠ [ABCDBCDNumber] No dates found, setting empty list');
      setDatesList([]);
      setSelectedDate('');
    } catch (e) {
      console.error('‚ùå [ABCDBCDNumber] Error loading user dates:', e);
      setDatesList([]);
      setSelectedDate('');
    }
  };

  const saveDatesToLocalStorage = async (uid, dates) => {
    try {
      await dataService.saveDates(uid, dates);
    } catch (e) {
      console.error('Error saving dates:', e);
    }
  };

  // Add new date
  const handleAddDate = () => {
    if (!newDate) {
      setDateError('Please select a date.');
      return;
    }
    
    if (!selectedUser) {
      setDateError('Please select a user first.');
      return;
    }
    
    try {
      const iso = new Date(newDate).toISOString().split('T')[0];
      const normalized = datesList.map(d => new Date(d).toISOString().split('T')[0]);
      
      if (normalized.includes(iso)) {
        setDateError('This date already exists.');
        return;
      }
      
      let updated = [...datesList, iso].sort((a, b) => new Date(b) - new Date(a));
      
      setDatesList(updated);
      setSelectedDate(iso);
      saveDatesToLocalStorage(selectedUser, updated);
      
      // Clear deletion flag when user adds a new date (re-enable sample data creation for future)
      localStorage.removeItem(`abcd_user_deleted_all_${selectedUser}`);
      console.log('üîÑ [ABCDBCDNumber] Cleared deletion flag - user added new date');
      
      setNewDate('');
      setDateError('');
      setShowAddDateModal(false);
      
      setSuccess(`Date ${new Date(iso).toLocaleDateString()} added successfully.`);
      setTimeout(() => setSuccess(''), 3000);
    } catch (e) {
      setDateError('An error occurred. Try again.');
    }
  };

  // Remove date
  const handleRemoveDate = async (dateToRemove) => {
    if (datesList.length <= 1) {
      const updated = datesList.filter(d => d !== dateToRemove);
      setDatesList(updated);
      await saveDatesToLocalStorage(selectedUser, updated);
      setSelectedDate('');
      setSuccess(`Date ${new Date(dateToRemove).toLocaleDateString()} removed.`);
      setTimeout(() => setSuccess(''), 3000);
      return;
    }
    
    const first = datesList[0];
    const last = datesList[datesList.length - 1];
    if (dateToRemove !== first && dateToRemove !== last) {
      setError('Only newest or oldest can be deleted directly.');
      setTimeout(() => setError(''), 5000);
      return;
    }
    
    const updated = datesList.filter(d => d !== dateToRemove);
    setDatesList(updated);
    
    if (selectedDate === dateToRemove) {
      if (updated.length > 0) setSelectedDate(updated[0]);
      else setSelectedDate('');
    }
    
    // ‚úÖ 1. Delete all data related to this date
    console.log('üóëÔ∏è [ABCDBCDNumber] Deleting date:', dateToRemove);
    await dataService.deleteDataForDate(selectedUser, dateToRemove);
    
    // ‚úÖ 2. Save updated date list WITHOUT the deleted date
    console.log('üíæ [ABCDBCDNumber] Saving updated dates list:', updated);
    await saveDatesToLocalStorage(selectedUser, updated);
    
    // ‚úÖ 2.5. Set deletion flag if all dates are deleted
    if (updated.length === 0) {
      localStorage.setItem(`abcd_user_deleted_all_${selectedUser}`, 'true');
      console.log('üóëÔ∏è [ABCDBCDNumber] Set deletion flag - all dates deleted');
    }
    
    // ‚úÖ 3. Reload the list from source of truth
    console.log('üîÑ [ABCDBCDNumber] Reloading dates from source of truth');
    await loadUserDates(selectedUser);
    
    // ‚úÖ 4. Clear status and verify cleanup
    setDateStatuses(prev => {
      const newStatus = { ...prev };
      delete newStatus[dateToRemove];
      return newStatus;
    });
    
    console.log('‚úÖ Deleted data and updated saved dates:', updated);
    
    const label = dateToRemove === first ? 'Newest' : 'Oldest';
    setSuccess(`${label} date ${new Date(dateToRemove).toLocaleDateString()} removed.`);
    setTimeout(() => setSuccess(''), 3000);
  };

  // Comprehensive ABCD Excel validation function
  const validateABCDExcelStructure = (worksheet) => {
    console.log('üîç Starting comprehensive ABCD Excel validation...');
    
    const range = XLSX.utils.decode_range(worksheet['!ref']);
    const errors = [];
    const warnings = [];
    
    // Expected structure
    const expectedTopics = 30;
    const expectedElements = [
      'as', 'mo', 'hl', 'gl', 'vig', 'var', 'sl', 'pp', 'in'
    ];
    const expectedPlanetsPerElement = 9; // Columns B-J (1-9)
    
    let topicsFound = 0;
    let currentTopicRow = -1;
    let elementsInCurrentTopic = 0;
    let totalDataCells = 0;
    let missingCells = [];
    
    // Analyze each row
    for (let row = 0; row <= range.e.r; row++) {
      const firstCell = worksheet[XLSX.utils.encode_cell({ r: row, c: 0 })];
      const firstCellValue = firstCell ? String(firstCell.v).trim() : '';
      
      // Check for topic headers (D-x Set-y Matrix)
      if (firstCellValue.includes('Matrix') && firstCellValue.match(/D-\d+.*Set-\d+.*Matrix/i)) {
        // Validate previous topic completion
        if (currentTopicRow >= 0 && elementsInCurrentTopic !== expectedElements.length) {
          errors.push(`Topic at row ${currentTopicRow + 1} is incomplete: found ${elementsInCurrentTopic}/${expectedElements.length} elements`);
        }
        
        topicsFound++;
        currentTopicRow = row;
        elementsInCurrentTopic = 0;
        console.log(`üìä Found topic ${topicsFound}: ${firstCellValue} at row ${row + 1}`);
        continue;
      }
      
      // Check for element rows within topics
      if (currentTopicRow >= 0 && firstCellValue.length <= 3 && firstCellValue.match(/^[a-z]+$/i)) {
        const elementCode = firstCellValue.toLowerCase();
        
        // Validate element is expected
        if (!expectedElements.includes(elementCode)) {
          errors.push(`Row ${row + 1}: Invalid element code "${elementCode}". Expected one of: ${expectedElements.join(', ')}`);
          continue;
        }
        
        // Check element order
        const expectedElement = expectedElements[elementsInCurrentTopic];
        if (elementCode !== expectedElement) {
          warnings.push(`Row ${row + 1}: Element "${elementCode}" out of expected order. Expected "${expectedElement}"`);
        }
        
        elementsInCurrentTopic++;
        
        // Validate planet data in columns B-J (indices 1-9)
        let planetDataCount = 0;
        for (let col = 1; col <= 9; col++) {
          const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
          const cell = worksheet[cellAddress];
          
          if (cell && cell.v !== null && cell.v !== undefined && String(cell.v).trim() !== '') {
            const cellValue = String(cell.v).trim();
            
            // Validate planet data format (should contain astrological data)
            if (!cellValue.match(/[a-z]+-\d+/i)) {
              errors.push(`Row ${row + 1}, Column ${String.fromCharCode(66 + col - 1)}: Invalid planet data format for element "${elementCode}". Expected format like "as-7-/su-(...)", found: "${cellValue}"`);
            } else {
              planetDataCount++;
              totalDataCells++;
            }
          } else {
            missingCells.push({
              row: row + 1,
              col: col + 1,
              element: elementCode,
              address: cellAddress
            });
          }
        }
        
        // Check if element has all required planet data
        if (planetDataCount < expectedPlanetsPerElement) {
          errors.push(`Row ${row + 1}: Element "${elementCode}" missing planet data. Found ${planetDataCount}/${expectedPlanetsPerElement} planets`);
        }
      }
    }
    
    // Final validation checks
    if (topicsFound < expectedTopics) {
      errors.push(`Insufficient topics found. Expected ${expectedTopics}, found ${topicsFound}`);
    }
    
    // Check total data cells (should be close to 3030 for complete file)
    const expectedTotalCells = expectedTopics * expectedElements.length * expectedPlanetsPerElement;
    if (totalDataCells < expectedTotalCells * 0.95) { // Allow 5% tolerance
      errors.push(`Insufficient data cells. Expected ~${expectedTotalCells}, found ${totalDataCells}`);
    }
    
    // Log results
    console.log('üìä ABCD Excel Validation Results:');
    console.log(`   - Topics found: ${topicsFound}/${expectedTopics}`);
    console.log(`   - Total data cells: ${totalDataCells}`);
    console.log(`   - Missing cells: ${missingCells.length}`);
    console.log(`   - Errors: ${errors.length}`);
    console.log(`   - Warnings: ${warnings.length}`);
    
    if (errors.length > 0) {
      console.log('‚ùå Validation Errors:', errors);
    }
    if (warnings.length > 0) {
      console.log('‚ö†Ô∏è Validation Warnings:', warnings);
    }
    
    // Return validation result
    const isValid = errors.length === 0;
    return {
      isValid,
      errors,
      warnings,
      topicsFound,
      totalDataCells,
      missingCells: missingCells.slice(0, 50), // Limit to first 50 missing cells
      summary: `Found ${topicsFound} topics with ${totalDataCells} data cells. ${missingCells.length} cells missing.`
    };
  };

  // Helper function to format validation errors for user-friendly display
  const formatValidationErrors = (validationResult) => {
    const { errors, warnings, topicsFound, totalDataCells, missingCells } = validationResult;
    
    if (errors.length === 0) return null;
    
    let message = '‚ùå Excel File Validation Failed\n\n';
    
    // Categorize errors
    const topicErrors = errors.filter(e => e.includes('Topic') || e.includes('Matrix'));
    const elementErrors = errors.filter(e => e.includes('element') || e.includes('order'));
    const dataErrors = errors.filter(e => e.includes('Missing') || e.includes('planet data'));
    const structureErrors = errors.filter(e => e.includes('Insufficient'));
    
    // Add summary
    message += `üìä Summary:\n`;
    message += `   ‚Ä¢ Topics found: ${topicsFound}/30\n`;
    message += `   ‚Ä¢ Data cells: ${totalDataCells}\n`;
    message += `   ‚Ä¢ Missing cells: ${missingCells.length}\n\n`;
    
    // Add most critical errors first
    if (structureErrors.length > 0) {
      message += `üèóÔ∏è Critical Issues:\n`;
      structureErrors.forEach(error => message += `   ‚Ä¢ ${error}\n`);
      message += '\n';
    }
    
    if (topicErrors.length > 0) {
      message += `üè∑Ô∏è Topic Issues (${topicErrors.length}):\n`;
      topicErrors.slice(0, 2).forEach(error => message += `   ‚Ä¢ ${error}\n`);
      if (topicErrors.length > 2) message += `   ‚Ä¢ ...and ${topicErrors.length - 2} more\n`;
      message += '\n';
    }
    
    if (dataErrors.length > 0) {
      message += `üìã Missing Data (${dataErrors.length} issues):\n`;
      dataErrors.slice(0, 3).forEach(error => message += `   ‚Ä¢ ${error}\n`);
      if (dataErrors.length > 3) message += `   ‚Ä¢ ...and ${dataErrors.length - 3} more\n`;
      message += '\n';
    }
    
    // Add helpful suggestions
    message += `üí° Requirements:\n`;
    message += `   ‚Ä¢ 30 topics with "D-x Set-y Matrix" headers\n`;
    message += `   ‚Ä¢ 9 elements per topic: as, mo, hl, gl, vig, var, sl, pp, in\n`;
    message += `   ‚Ä¢ Planet data in columns B-J for each element\n`;
    message += `   ‚Ä¢ Approximately 3030 total data cells\n`;
    
    return message;
  };

  // Handle Excel upload for specific date
  const handleDateExcelUpload = async (event, targetDate) => {
    try {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const worksheet = workbook.Sheets[workbook.SheetNames[0]];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

          // Validate Excel structure for ABCD format
          console.log('üîç Validating ABCD Excel structure...');
          const validationResult = validateABCDExcelStructure(worksheet);
          
          if (!validationResult.isValid) {
            // Format errors for better user experience
            const formattedMessage = formatValidationErrors(validationResult);
            throw new Error(formattedMessage || `Excel validation failed with ${validationResult.errors.length} errors.`);
          }
          
          // Show validation summary
          console.log('‚úÖ Excel validation passed:', validationResult.summary);
          if (validationResult.warnings.length > 0) {
            console.log('‚ö†Ô∏è Validation warnings:', validationResult.warnings);
          }

          const processedData = processSingleDayExcel(jsonData, targetDate);
          
          // Use DataService to save Excel data
          await dataService.saveExcelData(selectedUser, targetDate, {
            date: targetDate,
            fileName: file.name,
            data: processedData,
            uploadedAt: new Date().toISOString()
          });
          
          // Update date status for this specific date
          const excelUploaded = await dataService.hasExcelData(selectedUser, targetDate);
          const hourEntryCompleted = await dataService.hasHourEntry(selectedUser, targetDate);
          setDateStatuses(prev => ({
            ...prev,
            [targetDate]: {
              excelUploaded,
              hourEntryCompleted
            }
          }));
          
          setSuccess(`Excel uploaded successfully for ${new Date(targetDate).toLocaleDateString()}`);
          setTimeout(() => setSuccess(''), 3000);
          
          setDatesList([...datesList]);
          
        } catch (error) {
          setError(`Failed to process Excel file: ${error.message}`);
          setTimeout(() => setError(''), 5000);
        }
      };

      reader.readAsArrayBuffer(file);
      event.target.value = null;
      
    } catch (error) {
      setError(`Failed to upload file: ${error.message}`);
      setTimeout(() => setError(''), 5000);
    }
  };

  // Process single day Excel data - Updated for planet-based format
  const processSingleDayExcel = (rows, targetDate) => {
    console.log(`üîç Processing Excel with all 9 planets for ${targetDate}, ${rows.length} rows`);
    
    const result = {
      date: targetDate,
      sets: {},
      planets: {}
    };
    
    // Planet mapping for columns
    const planetMapping = {
      1: 'Su',   // Sun
      2: 'Mo',   // Moon  
      3: 'Ma',   // Mars
      4: 'Me',   // Mercury
      5: 'Ju',   // Jupiter
      6: 'Ve',   // Venus
      7: 'Sa',   // Saturn
      8: 'Ra',   // Rahu
      9: 'Ke'    // Ketu
    };
    
    // Element name mapping
    const elementNames = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    let currentSet = null;
    let currentSetData = {};
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Detect set headers (e.g., "D-1 Set-1 Matrix")
      if (firstCell.includes('Matrix') && (firstCell.includes('D-') || firstCell.includes('Set-'))) {
        // Save previous set if exists
        if (currentSet && Object.keys(currentSetData).length > 0) {
          result.sets[currentSet] = { ...currentSetData };
        }
        
        currentSet = firstCell;
        currentSetData = {};
        console.log(`üìä Found set: ${currentSet}`);
        continue;
      }
      
      // Skip planet header rows (x, Sun, Moon, Mars, etc.)
      if (firstCell.toLowerCase() === 'x' || 
          ['sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
          .some(planet => firstCell.toLowerCase().includes(planet))) {
        console.log(`ü™ê Skipping planet header row: ${firstCell}`);
        continue;
      }
      
      // Process element rows (as, mo, hl, gl, etc.)
      if (currentSet && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        
        if (elementNames[elementCode]) {
          const elementName = elementNames[elementCode];
          const planetData = {};
          
          // Extract data for each planet column (columns 1-9)
          for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
            const cellValue = row[colIndex];
            if (cellValue && typeof cellValue === 'string' && cellValue.trim()) {
              const planetCode = planetMapping[colIndex];
              planetData[planetCode] = cellValue.trim();
            }
          }
          
          if (Object.keys(planetData).length > 0) {
            currentSetData[elementName] = planetData;
            console.log(`  üìù ${elementName}: ${Object.keys(planetData).length} planets`);
          }
        }
      }
    }
    
    // Save the last set
    if (currentSet && Object.keys(currentSetData).length > 0) {
      result.sets[currentSet] = { ...currentSetData };
    }
    
    console.log(`‚úÖ Processed ${Object.keys(result.sets).length} sets for ${targetDate}`);
    console.log('üìã Sets found:', Object.keys(result.sets));
    
    return result;
  };

  // Strict Excel validation function
  const validateStrictExcelData = (rows) => {
    console.log('üîç Starting strict Excel validation...');
    
    // Required elements in exact order
    const requiredElements = [
      'Lagna',
      'Moon', 
      'Hora Lagna',
      'Ghati Lagna',
      'Vighati Lagna',
      'Varnada Lagna',
      'Sree Lagna',
      'Pranapada Lagna',
      'Indu Lagna'
    ];
    
    // Element code mapping
    const elementCodeToName = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    const errors = [];
    let currentTopicIndex = -1;
    let elementIndex = 0;
    let inTopic = false;
    let topicsFound = 0;
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Check for topic header (D-x Set-y Matrix)
      if (firstCell.includes('Matrix') && firstCell.match(/D-\d+\s+Set-\d+\s+Matrix/)) {
        console.log(`‚úÖ Found valid topic header: ${firstCell}`);
        
        if (inTopic && elementIndex < requiredElements.length) {
          errors.push(`Topic "${rows[currentTopicIndex][0]}" is incomplete. Expected ${requiredElements.length} elements, found ${elementIndex}`);
        }
        
        currentTopicIndex = i;
        elementIndex = 0;
        inTopic = true;
        topicsFound++;
        continue;
      }
      
      // If we're in a topic, validate element rows
      if (inTopic && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        const expectedElementName = elementCodeToName[elementCode];
        
        if (!expectedElementName) {
          // Skip non-element rows (like planet headers)
          if (['x', 'sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
              .some(header => firstCell.toLowerCase().includes(header.toLowerCase()))) {
            continue;
          }
          errors.push(`Row ${i + 1}: Invalid element code "${elementCode}"`);
          continue;
        }
        
        // Check if element is in correct order
        if (elementIndex >= requiredElements.length) {
          errors.push(`Row ${i + 1}: Too many elements in topic. Expected only ${requiredElements.length} elements`);
          continue;
        }
        
        const expectedElement = requiredElements[elementIndex];
        if (expectedElementName !== expectedElement) {
          errors.push(`Row ${i + 1}: Element out of order. Expected "${expectedElement}", found "${expectedElementName}"`);
        }
        
        // Validate planet data in columns B-J (indices 1-9)
        let hasValidData = false;
        for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
          const cellValue = row[colIndex];
          
          // Check for missing, blank, or placeholder values
          if (!cellValue || 
              cellValue === null || 
              cellValue === undefined ||
              String(cellValue).trim() === '' ||
              String(cellValue).trim() === '‚Äî' ||
              String(cellValue).trim() === '-' ||
              String(cellValue).trim() === 'N/A' ||
              String(cellValue).trim() === 'NA' ||
              String(cellValue).trim().toLowerCase() === 'null') {
            
            const columnLetter = String.fromCharCode(65 + colIndex); // B, C, D, etc.
            errors.push(`Row ${i + 1}, Column ${columnLetter}: Missing or invalid planet data for ${expectedElementName}. Found: "${cellValue}"`);
          } else {
            // Check if it looks like valid planet data (basic format check)
            const cellStr = String(cellValue).trim();
            if (cellStr.length > 0) {
              // Valid planet data should have some structure (e.g., contain letters and numbers)
              if (!/^[a-z]+-\d+/.test(cellStr.toLowerCase())) {
                const columnLetter = String.fromCharCode(65 + colIndex);
                errors.push(`Row ${i + 1}, Column ${columnLetter}: Invalid planet data format for ${expectedElementName}. Expected format like "as-7-/su-(...)", found: "${cellStr}"`);
              } else {
                hasValidData = true;
              }
            }
          }
        }
        
        if (!hasValidData) {
          errors.push(`Row ${i + 1}: No valid planet data found for ${expectedElementName} in any column`);
        }
        
        elementIndex++;
      }
    }
    
    // Final validation checks
    if (topicsFound === 0) {
      errors.push('No valid topic blocks found. Each topic must start with "D-x Set-y Matrix" format');
    }
    
    // Allow incomplete topics - only warn if topic has no elements at all
    if (inTopic && elementIndex === 0) {
      errors.push(`Topic "${rows[currentTopicIndex][0]}" has no elements`);
    }
    
    // Check that we have complete topics
    if (topicsFound > 0) {
      console.log(`‚úÖ Found ${topicsFound} topic blocks`);
    }
    
    if (errors.length > 0) {
      console.log('‚ùå Validation failed with errors:', errors);
      return {
        isValid: false,
        errors: errors,
        message: `Excel validation failed with ${errors.length} error(s):\n\n${errors.join('\n')}`
      };
    }
    
    console.log('‚úÖ Excel validation passed successfully');
    return {
      isValid: true,
      errors: [],
      message: 'Excel file validation passed'
    };
  };

  // Helper function to format validation errors for user-friendly display
  const formatValidationErrors = (validationResult) => {
    const { errors, warnings, topicsFound, totalDataCells, missingCells } = validationResult;
    
    if (errors.length === 0) {
      return null;
    }
    
    let message = '‚ùå Excel File Validation Failed\n\n';
    
    // Categorize errors
    const topicErrors = errors.filter(e => e.includes('Topic') || e.includes('Matrix'));
    const elementErrors = errors.filter(e => e.includes('element') || e.includes('order'));
    const dataErrors = errors.filter(e => e.includes('Missing') || e.includes('planet data'));
    const structureErrors = errors.filter(e => e.includes('Insufficient'));
    
    // Add summary
    message += `üìä Summary:\n`;
    message += `   ‚Ä¢ Topics found: ${topicsFound}/30\n`;
    message += `   ‚Ä¢ Data cells: ${totalDataCells}\n`;
    message += `   ‚Ä¢ Missing cells: ${missingCells.length}\n\n`;
    
    // Add categorized errors
    if (topicErrors.length > 0) {
      message += `üè∑Ô∏è Topic Issues (${topicErrors.length}):\n`;
      topicErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (topicErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${topicErrors.length - 3} more topic issues\n`;
      }
      message += '\n';
    }
    
    if (elementErrors.length > 0) {
      message += `üß± Element Issues (${elementErrors.length}):\n`;
      elementErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (elementErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${elementErrors.length - 3} more element issues\n`;
      }
      message += '\n';
    }
    
    if (dataErrors.length > 0) {
      message += `üìã Data Issues (${dataErrors.length}):\n`;
      dataErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (dataErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${dataErrors.length - 3} more data issues\n`;
      }
      message += '\n';
    }
    
    if (structureErrors.length > 0) {
      message += `üèóÔ∏è Structure Issues:\n`;
      structureErrors.forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      message += '\n';
    }
    
    // Add helpful suggestions
    message += `üí° Suggestions:\n`;
    message += `   ‚Ä¢ Ensure your Excel has 30 topics (D-1 Set-1 Matrix, D-1 Set-2 Matrix, etc.)\n`;
    message += `   ‚Ä¢ Each topic should have 9 elements: as, mo, hl, gl, vig, var, sl, pp, in\n`;
    message += `   ‚Ä¢ Each element should have data in columns B through J (9 planets)\n`;
    message += `   ‚Ä¢ Check for missing or empty cells in the data area\n`;
    
    return message;
  };

  // Handle Excel upload for specific date
  const handleDateExcelUpload = async (event, targetDate) => {
    try {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const worksheet = workbook.Sheets[workbook.SheetNames[0]];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

          // Validate Excel structure for ABCD format
          console.log('üîç Validating ABCD Excel structure...');
          const validationResult = validateABCDExcelStructure(worksheet);
          
          if (!validationResult.isValid) {
            const formattedErrors = formatValidationErrors(validationResult);
            setError(formattedErrors);
            setTimeout(() => setError(''), 5000);
            return;
          }
          
          // Show validation summary
          console.log('‚úÖ Excel validation passed:', validationResult.summary);
          if (validationResult.warnings.length > 0) {
            console.log('‚ö†Ô∏è Validation warnings:', validationResult.warnings);
          }

          const processedData = processSingleDayExcel(jsonData, targetDate);
          
          // Use DataService to save Excel data
          await dataService.saveExcelData(selectedUser, targetDate, {
            date: targetDate,
            fileName: file.name,
            data: processedData,
            uploadedAt: new Date().toISOString()
          });
          
          // Update date status for this specific date
          const excelUploaded = await dataService.hasExcelData(selectedUser, targetDate);
          const hourEntryCompleted = await dataService.hasHourEntry(selectedUser, targetDate);
          setDateStatuses(prev => ({
            ...prev,
            [targetDate]: {
              excelUploaded,
              hourEntryCompleted
            }
          }));
          
          setSuccess(`Excel uploaded successfully for ${new Date(targetDate).toLocaleDateString()}`);
          setTimeout(() => setSuccess(''), 3000);
          
          setDatesList([...datesList]);
          
        } catch (error) {
          setError(`Failed to process Excel file: ${error.message}`);
          setTimeout(() => setError(''), 5000);
        }
      };

      reader.readAsArrayBuffer(file);
      event.target.value = null;
      
    } catch (error) {
      setError(`Failed to upload file: ${error.message}`);
      setTimeout(() => setError(''), 5000);
    }
  };

  // Process single day Excel data - Updated for planet-based format
  const processSingleDayExcel = (rows, targetDate) => {
    console.log(`üîç Processing Excel with all 9 planets for ${targetDate}, ${rows.length} rows`);
    
    const result = {
      date: targetDate,
      sets: {},
      planets: {}
    };
    
    // Planet mapping for columns
    const planetMapping = {
      1: 'Su',   // Sun
      2: 'Mo',   // Moon  
      3: 'Ma',   // Mars
      4: 'Me',   // Mercury
      5: 'Ju',   // Jupiter
      6: 'Ve',   // Venus
      7: 'Sa',   // Saturn
      8: 'Ra',   // Rahu
      9: 'Ke'    // Ketu
    };
    
    // Element name mapping
    const elementNames = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    let currentSet = null;
    let currentSetData = {};
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Detect set headers (e.g., "D-1 Set-1 Matrix")
      if (firstCell.includes('Matrix') && (firstCell.includes('D-') || firstCell.includes('Set-'))) {
        // Save previous set if exists
        if (currentSet && Object.keys(currentSetData).length > 0) {
          result.sets[currentSet] = { ...currentSetData };
        }
        
        currentSet = firstCell;
        currentSetData = {};
        console.log(`üìä Found set: ${currentSet}`);
        continue;
      }
      
      // Skip planet header rows (x, Sun, Moon, Mars, etc.)
      if (firstCell.toLowerCase() === 'x' || 
          ['sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
          .some(planet => firstCell.toLowerCase().includes(planet))) {
        console.log(`ü™ê Skipping planet header row: ${firstCell}`);
        continue;
      }
      
      // Process element rows (as, mo, hl, gl, etc.)
      if (currentSet && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        
        if (elementNames[elementCode]) {
          const elementName = elementNames[elementCode];
          const planetData = {};
          
          // Extract data for each planet column (columns 1-9)
          for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
            const cellValue = row[colIndex];
            if (cellValue && typeof cellValue === 'string' && cellValue.trim()) {
              const planetCode = planetMapping[colIndex];
              planetData[planetCode] = cellValue.trim();
            }
          }
          
          if (Object.keys(planetData).length > 0) {
            currentSetData[elementName] = planetData;
            console.log(`  üìù ${elementName}: ${Object.keys(planetData).length} planets`);
          }
        }
      }
    }
    
    // Save the last set
    if (currentSet && Object.keys(currentSetData).length > 0) {
      result.sets[currentSet] = { ...currentSetData };
    }
    
    console.log(`‚úÖ Processed ${Object.keys(result.sets).length} sets for ${targetDate}`);
    console.log('üìã Sets found:', Object.keys(result.sets));
    
    return result;
  };

  // Strict Excel validation function
  const validateStrictExcelData = (rows) => {
    console.log('üîç Starting strict Excel validation...');
    
    // Required elements in exact order
    const requiredElements = [
      'Lagna',
      'Moon', 
      'Hora Lagna',
      'Ghati Lagna',
      'Vighati Lagna',
      'Varnada Lagna',
      'Sree Lagna',
      'Pranapada Lagna',
      'Indu Lagna'
    ];
    
    // Element code mapping
    const elementCodeToName = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    const errors = [];
    let currentTopicIndex = -1;
    let elementIndex = 0;
    let inTopic = false;
    let topicsFound = 0;
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Check for topic header (D-x Set-y Matrix)
      if (firstCell.includes('Matrix') && firstCell.match(/D-\d+\s+Set-\d+\s+Matrix/)) {
        console.log(`‚úÖ Found valid topic header: ${firstCell}`);
        
        if (inTopic && elementIndex < requiredElements.length) {
          errors.push(`Topic "${rows[currentTopicIndex][0]}" is incomplete. Expected ${requiredElements.length} elements, found ${elementIndex}`);
        }
        
        currentTopicIndex = i;
        elementIndex = 0;
        inTopic = true;
        topicsFound++;
        continue;
      }
      
      // If we're in a topic, validate element rows
      if (inTopic && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        const expectedElementName = elementCodeToName[elementCode];
        
        if (!expectedElementName) {
          // Skip non-element rows (like planet headers)
          if (['x', 'sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
              .some(header => firstCell.toLowerCase().includes(header.toLowerCase()))) {
            continue;
          }
          errors.push(`Row ${i + 1}: Invalid element code "${elementCode}"`);
          continue;
        }
        
        // Check if element is in correct order
        if (elementIndex >= requiredElements.length) {
          errors.push(`Row ${i + 1}: Too many elements in topic. Expected only ${requiredElements.length} elements`);
          continue;
        }
        
        const expectedElement = requiredElements[elementIndex];
        if (expectedElementName !== expectedElement) {
          errors.push(`Row ${i + 1}: Element out of order. Expected "${expectedElement}", found "${expectedElementName}"`);
        }
        
        // Validate planet data in columns B-J (indices 1-9)
        let hasValidData = false;
        for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
          const cellValue = row[colIndex];
          
          // Check for missing, blank, or placeholder values
          if (!cellValue || 
              cellValue === null || 
              cellValue === undefined ||
              String(cellValue).trim() === '' ||
              String(cellValue).trim() === '‚Äî' ||
              String(cellValue).trim() === '-' ||
              String(cellValue).trim() === 'N/A' ||
              String(cellValue).trim() === 'NA' ||
              String(cellValue).trim().toLowerCase() === 'null') {
            
            const columnLetter = String.fromCharCode(65 + colIndex); // B, C, D, etc.
            errors.push(`Row ${i + 1}, Column ${columnLetter}: Missing or invalid planet data for ${expectedElementName}. Found: "${cellValue}"`);
          } else {
            // Check if it looks like valid planet data (basic format check)
            const cellStr = String(cellValue).trim();
            if (cellStr.length > 0) {
              // Valid planet data should have some structure (e.g., contain letters and numbers)
              if (!/^[a-z]+-\d+/.test(cellStr.toLowerCase())) {
                const columnLetter = String.fromCharCode(65 + colIndex);
                errors.push(`Row ${i + 1}, Column ${columnLetter}: Invalid planet data format for ${expectedElementName}. Expected format like "as-7-/su-(...)", found: "${cellStr}"`);
              } else {
                hasValidData = true;
              }
            }
          }
        }
        
        if (!hasValidData) {
          errors.push(`Row ${i + 1}: No valid planet data found for ${expectedElementName} in any column`);
        }
        
        elementIndex++;
      }
    }
    
    // Final validation checks
    if (topicsFound === 0) {
      errors.push('No valid topic blocks found. Each topic must start with "D-x Set-y Matrix" format');
    }
    
    // Allow incomplete topics - only warn if topic has no elements at all
    if (inTopic && elementIndex === 0) {
      errors.push(`Topic "${rows[currentTopicIndex][0]}" has no elements`);
    }
    
    // Check that we have complete topics
    if (topicsFound > 0) {
      console.log(`‚úÖ Found ${topicsFound} topic blocks`);
    }
    
    if (errors.length > 0) {
      console.log('‚ùå Validation failed with errors:', errors);
      return {
        isValid: false,
        errors: errors,
        message: `Excel validation failed with ${errors.length} error(s):\n\n${errors.join('\n')}`
      };
    }
    
    console.log('‚úÖ Excel validation passed successfully');
    return {
      isValid: true,
      errors: [],
      message: 'Excel file validation passed'
    };
  };

  // Helper function to format validation errors for user-friendly display
  const formatValidationErrors = (validationResult) => {
    const { errors, warnings, topicsFound, totalDataCells, missingCells } = validationResult;
    
    if (errors.length === 0) {
      return null;
    }
    
    let message = '‚ùå Excel File Validation Failed\n\n';
    
    // Categorize errors
    const topicErrors = errors.filter(e => e.includes('Topic') || e.includes('Matrix'));
    const elementErrors = errors.filter(e => e.includes('element') || e.includes('order'));
    const dataErrors = errors.filter(e => e.includes('Missing') || e.includes('planet data'));
    const structureErrors = errors.filter(e => e.includes('Insufficient'));
    
    // Add summary
    message += `üìä Summary:\n`;
    message += `   ‚Ä¢ Topics found: ${topicsFound}/30\n`;
    message += `   ‚Ä¢ Data cells: ${totalDataCells}\n`;
    message += `   ‚Ä¢ Missing cells: ${missingCells.length}\n\n`;
    
    // Add categorized errors
    if (topicErrors.length > 0) {
      message += `üè∑Ô∏è Topic Issues (${topicErrors.length}):\n`;
      topicErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (topicErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${topicErrors.length - 3} more topic issues\n`;
      }
      message += '\n';
    }
    
    if (elementErrors.length > 0) {
      message += `üß± Element Issues (${elementErrors.length}):\n`;
      elementErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (elementErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${elementErrors.length - 3} more element issues\n`;
      }
      message += '\n';
    }
    
    if (dataErrors.length > 0) {
      message += `üìã Data Issues (${dataErrors.length}):\n`;
      dataErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (dataErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${dataErrors.length - 3} more data issues\n`;
      }
      message += '\n';
    }
    
    if (structureErrors.length > 0) {
      message += `üèóÔ∏è Structure Issues:\n`;
      structureErrors.forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      message += '\n';
    }
    
    // Add helpful suggestions
    message += `üí° Suggestions:\n`;
    message += `   ‚Ä¢ Ensure your Excel has 30 topics (D-1 Set-1 Matrix, D-1 Set-2 Matrix, etc.)\n`;
    message += `   ‚Ä¢ Each topic should have 9 elements: as, mo, hl, gl, vig, var, sl, pp, in\n`;
    message += `   ‚Ä¢ Each element should have data in columns B through J (9 planets)\n`;
    message += `   ‚Ä¢ Check for missing or empty cells in the data area\n`;
    
    return message;
  };

  // Handle Excel upload for specific date
  const handleDateExcelUpload = async (event, targetDate) => {
    try {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const worksheet = workbook.Sheets[workbook.SheetNames[0]];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

          // Validate Excel structure for ABCD format
          console.log('üîç Validating ABCD Excel structure...');
          const validationResult = validateABCDExcelStructure(worksheet);
          
          if (!validationResult.isValid) {
            const formattedErrors = formatValidationErrors(validationResult);
            setError(formattedErrors);
            setTimeout(() => setError(''), 5000);
            return;
          }
          
          // Show validation summary
          console.log('‚úÖ Excel validation passed:', validationResult.summary);
          if (validationResult.warnings.length > 0) {
            console.log('‚ö†Ô∏è Validation warnings:', validationResult.warnings);
          }

          const processedData = processSingleDayExcel(jsonData, targetDate);
          
          // Use DataService to save Excel data
          await dataService.saveExcelData(selectedUser, targetDate, {
            date: targetDate,
            fileName: file.name,
            data: processedData,
            uploadedAt: new Date().toISOString()
          });
          
          // Update date status for this specific date
          const excelUploaded = await dataService.hasExcelData(selectedUser, targetDate);
          const hourEntryCompleted = await dataService.hasHourEntry(selectedUser, targetDate);
          setDateStatuses(prev => ({
            ...prev,
            [targetDate]: {
              excelUploaded,
              hourEntryCompleted
            }
          }));
          
          setSuccess(`Excel uploaded successfully for ${new Date(targetDate).toLocaleDateString()}`);
          setTimeout(() => setSuccess(''), 3000);
          
          setDatesList([...datesList]);
          
        } catch (error) {
          setError(`Failed to process Excel file: ${error.message}`);
          setTimeout(() => setError(''), 5000);
        }
      };

      reader.readAsArrayBuffer(file);
      event.target.value = null;
      
    } catch (error) {
      setError(`Failed to upload file: ${error.message}`);
      setTimeout(() => setError(''), 5000);
    }
  };

  // Process single day Excel data - Updated for planet-based format
  const processSingleDayExcel = (rows, targetDate) => {
    console.log(`üîç Processing Excel with all 9 planets for ${targetDate}, ${rows.length} rows`);
    
    const result = {
      date: targetDate,
      sets: {},
      planets: {}
    };
    
    // Planet mapping for columns
    const planetMapping = {
      1: 'Su',   // Sun
      2: 'Mo',   // Moon  
      3: 'Ma',   // Mars
      4: 'Me',   // Mercury
      5: 'Ju',   // Jupiter
      6: 'Ve',   // Venus
      7: 'Sa',   // Saturn
      8: 'Ra',   // Rahu
      9: 'Ke'    // Ketu
    };
    
    // Element name mapping
    const elementNames = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    let currentSet = null;
    let currentSetData = {};
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Detect set headers (e.g., "D-1 Set-1 Matrix")
      if (firstCell.includes('Matrix') && (firstCell.includes('D-') || firstCell.includes('Set-'))) {
        // Save previous set if exists
        if (currentSet && Object.keys(currentSetData).length > 0) {
          result.sets[currentSet] = { ...currentSetData };
        }
        
        currentSet = firstCell;
        currentSetData = {};
        console.log(`üìä Found set: ${currentSet}`);
        continue;
      }
      
      // Skip planet header rows (x, Sun, Moon, Mars, etc.)
      if (firstCell.toLowerCase() === 'x' || 
          ['sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
          .some(planet => firstCell.toLowerCase().includes(planet))) {
        console.log(`ü™ê Skipping planet header row: ${firstCell}`);
        continue;
      }
      
      // Process element rows (as, mo, hl, gl, etc.)
      if (currentSet && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        
        if (elementNames[elementCode]) {
          const elementName = elementNames[elementCode];
          const planetData = {};
          
          // Extract data for each planet column (columns 1-9)
          for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
            const cellValue = row[colIndex];
            if (cellValue && typeof cellValue === 'string' && cellValue.trim()) {
              const planetCode = planetMapping[colIndex];
              planetData[planetCode] = cellValue.trim();
            }
          }
          
          if (Object.keys(planetData).length > 0) {
            currentSetData[elementName] = planetData;
            console.log(`  üìù ${elementName}: ${Object.keys(planetData).length} planets`);
          }
        }
      }
    }
    
    // Save the last set
    if (currentSet && Object.keys(currentSetData).length > 0) {
      result.sets[currentSet] = { ...currentSetData };
    }
    
    console.log(`‚úÖ Processed ${Object.keys(result.sets).length} sets for ${targetDate}`);
    console.log('üìã Sets found:', Object.keys(result.sets));
    
    return result;
  };

  // Strict Excel validation function
  const validateStrictExcelData = (rows) => {
    console.log('üîç Starting strict Excel validation...');
    
    // Required elements in exact order
    const requiredElements = [
      'Lagna',
      'Moon', 
      'Hora Lagna',
      'Ghati Lagna',
      'Vighati Lagna',
      'Varnada Lagna',
      'Sree Lagna',
      'Pranapada Lagna',
      'Indu Lagna'
    ];
    
    // Element code mapping
    const elementCodeToName = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    const errors = [];
    let currentTopicIndex = -1;
    let elementIndex = 0;
    let inTopic = false;
    let topicsFound = 0;
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Check for topic header (D-x Set-y Matrix)
      if (firstCell.includes('Matrix') && firstCell.match(/D-\d+\s+Set-\d+\s+Matrix/)) {
        console.log(`‚úÖ Found valid topic header: ${firstCell}`);
        
        if (inTopic && elementIndex < requiredElements.length) {
          errors.push(`Topic "${rows[currentTopicIndex][0]}" is incomplete. Expected ${requiredElements.length} elements, found ${elementIndex}`);
        }
        
        currentTopicIndex = i;
        elementIndex = 0;
        inTopic = true;
        topicsFound++;
        continue;
      }
      
      // If we're in a topic, validate element rows
      if (inTopic && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        const expectedElementName = elementCodeToName[elementCode];
        
        if (!expectedElementName) {
          // Skip non-element rows (like planet headers)
          if (['x', 'sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
              .some(header => firstCell.toLowerCase().includes(header.toLowerCase()))) {
            continue;
          }
          errors.push(`Row ${i + 1}: Invalid element code "${elementCode}"`);
          continue;
        }
        
        // Check if element is in correct order
        if (elementIndex >= requiredElements.length) {
          errors.push(`Row ${i + 1}: Too many elements in topic. Expected only ${requiredElements.length} elements`);
          continue;
        }
        
        const expectedElement = requiredElements[elementIndex];
        if (expectedElementName !== expectedElement) {
          errors.push(`Row ${i + 1}: Element out of order. Expected "${expectedElement}", found "${expectedElementName}"`);
        }
        
        // Validate planet data in columns B-J (indices 1-9)
        let hasValidData = false;
        for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
          const cellValue = row[colIndex];
          
          // Check for missing, blank, or placeholder values
          if (!cellValue || 
              cellValue === null || 
              cellValue === undefined ||
              String(cellValue).trim() === '' ||
              String(cellValue).trim() === '‚Äî' ||
              String(cellValue).trim() === '-' ||
              String(cellValue).trim() === 'N/A' ||
              String(cellValue).trim() === 'NA' ||
              String(cellValue).trim().toLowerCase() === 'null') {
            
            const columnLetter = String.fromCharCode(65 + colIndex); // B, C, D, etc.
            errors.push(`Row ${i + 1}, Column ${columnLetter}: Missing or invalid planet data for ${expectedElementName}. Found: "${cellValue}"`);
          } else {
            // Check if it looks like valid planet data (basic format check)
            const cellStr = String(cellValue).trim();
            if (cellStr.length > 0) {
              // Valid planet data should have some structure (e.g., contain letters and numbers)
              if (!/^[a-z]+-\d+/.test(cellStr.toLowerCase())) {
                const columnLetter = String.fromCharCode(65 + colIndex);
                errors.push(`Row ${i + 1}, Column ${columnLetter}: Invalid planet data format for ${expectedElementName}. Expected format like "as-7-/su-(...)", found: "${cellStr}"`);
              } else {
                hasValidData = true;
              }
            }
          }
        }
        
        if (!hasValidData) {
          errors.push(`Row ${i + 1}: No valid planet data found for ${expectedElementName} in any column`);
        }
        
        elementIndex++;
      }
    }
    
    // Final validation checks
    if (topicsFound === 0) {
      errors.push('No valid topic blocks found. Each topic must start with "D-x Set-y Matrix" format');
    }
    
    // Allow incomplete topics - only warn if topic has no elements at all
    if (inTopic && elementIndex === 0) {
      errors.push(`Topic "${rows[currentTopicIndex][0]}" has no elements`);
    }
    
    // Check that we have complete topics
    if (topicsFound > 0) {
      console.log(`‚úÖ Found ${topicsFound} topic blocks`);
    }
    
    if (errors.length > 0) {
      console.log('‚ùå Validation failed with errors:', errors);
      return {
        isValid: false,
        errors: errors,
        message: `Excel validation failed with ${errors.length} error(s):\n\n${errors.join('\n')}`
      };
    }
    
    console.log('‚úÖ Excel validation passed successfully');
    return {
      isValid: true,
      errors: [],
      message: 'Excel file validation passed'
    };
  };

  // Helper function to format validation errors for user-friendly display
  const formatValidationErrors = (validationResult) => {
    const { errors, warnings, topicsFound, totalDataCells, missingCells } = validationResult;
    
    if (errors.length === 0) {
      return null;
    }
    
    let message = '‚ùå Excel File Validation Failed\n\n';
    
    // Categorize errors
    const topicErrors = errors.filter(e => e.includes('Topic') || e.includes('Matrix'));
    const elementErrors = errors.filter(e => e.includes('element') || e.includes('order'));
    const dataErrors = errors.filter(e => e.includes('Missing') || e.includes('planet data'));
    const structureErrors = errors.filter(e => e.includes('Insufficient'));
    
    // Add summary
    message += `üìä Summary:\n`;
    message += `   ‚Ä¢ Topics found: ${topicsFound}/30\n`;
    message += `   ‚Ä¢ Data cells: ${totalDataCells}\n`;
    message += `   ‚Ä¢ Missing cells: ${missingCells.length}\n\n`;
    
    // Add categorized errors
    if (topicErrors.length > 0) {
      message += `üè∑Ô∏è Topic Issues (${topicErrors.length}):\n`;
      topicErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (topicErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${topicErrors.length - 3} more topic issues\n`;
      }
      message += '\n';
    }
    
    if (elementErrors.length > 0) {
      message += `üß± Element Issues (${elementErrors.length}):\n`;
      elementErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (elementErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${elementErrors.length - 3} more element issues\n`;
      }
      message += '\n';
    }
    
    if (dataErrors.length > 0) {
      message += `üìã Data Issues (${dataErrors.length}):\n`;
      dataErrors.slice(0, 3).forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      if (dataErrors.length > 3) {
        message += `   ‚Ä¢ ...and ${dataErrors.length - 3} more data issues\n`;
      }
      message += '\n';
    }
    
    if (structureErrors.length > 0) {
      message += `üèóÔ∏è Structure Issues:\n`;
      structureErrors.forEach(error => {
        message += `   ‚Ä¢ ${error}\n`;
      });
      message += '\n';
    }
    
    // Add helpful suggestions
    message += `üí° Suggestions:\n`;
    message += `   ‚Ä¢ Ensure your Excel has 30 topics (D-1 Set-1 Matrix, D-1 Set-2 Matrix, etc.)\n`;
    message += `   ‚Ä¢ Each topic should have 9 elements: as, mo, hl, gl, vig, var, sl, pp, in\n`;
    message += `   ‚Ä¢ Each element should have data in columns B through J (9 planets)\n`;
    message += `   ‚Ä¢ Check for missing or empty cells in the data area\n`;
    
    return message;
  };

  // Handle Excel upload for specific date
  const handleDateExcelUpload = async (event, targetDate) => {
    try {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const worksheet = workbook.Sheets[workbook.SheetNames[0]];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

          // Validate Excel structure for ABCD format
          console.log('üîç Validating ABCD Excel structure...');
          const validationResult = validateABCDExcelStructure(worksheet);
          
          if (!validationResult.isValid) {
            const formattedErrors = formatValidationErrors(validationResult);
            setError(formattedErrors);
            setTimeout(() => setError(''), 5000);
            return;
          }
          
          // Show validation summary
          console.log('‚úÖ Excel validation passed:', validationResult.summary);
          if (validationResult.warnings.length > 0) {
            console.log('‚ö†Ô∏è Validation warnings:', validationResult.warnings);
          }

          const processedData = processSingleDayExcel(jsonData, targetDate);
          
          // Use DataService to save Excel data
          await dataService.saveExcelData(selectedUser, targetDate, {
            date: targetDate,
            fileName: file.name,
            data: processedData,
            uploadedAt: new Date().toISOString()
          });
          
          // Update date status for this specific date
          const excelUploaded = await dataService.hasExcelData(selectedUser, targetDate);
          const hourEntryCompleted = await dataService.hasHourEntry(selectedUser, targetDate);
          setDateStatuses(prev => ({
            ...prev,
            [targetDate]: {
              excelUploaded,
              hourEntryCompleted
            }
          }));
          
          setSuccess(`Excel uploaded successfully for ${new Date(targetDate).toLocaleDateString()}`);
          setTimeout(() => setSuccess(''), 3000);
          
          setDatesList([...datesList]);
          
        } catch (error) {
          setError(`Failed to process Excel file: ${error.message}`);
          setTimeout(() => setError(''), 5000);
        }
      };

      reader.readAsArrayBuffer(file);
      event.target.value = null;
      
    } catch (error) {
      setError(`Failed to upload file: ${error.message}`);
      setTimeout(() => setError(''), 5000);
    }
  };

  // Process single day Excel data - Updated for planet-based format
  const processSingleDayExcel = (rows, targetDate) => {
    console.log(`üîç Processing Excel with all 9 planets for ${targetDate}, ${rows.length} rows`);
    
    const result = {
      date: targetDate,
      sets: {},
      planets: {}
    };
    
    // Planet mapping for columns
    const planetMapping = {
      1: 'Su',   // Sun
      2: 'Mo',   // Moon  
      3: 'Ma',   // Mars
      4: 'Me',   // Mercury
      5: 'Ju',   // Jupiter
      6: 'Ve',   // Venus
      7: 'Sa',   // Saturn
      8: 'Ra',   // Rahu
      9: 'Ke'    // Ketu
    };
    
    // Element name mapping
    const elementNames = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    let currentSet = null;
    let currentSetData = {};
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Detect set headers (e.g., "D-1 Set-1 Matrix")
      if (firstCell.includes('Matrix') && (firstCell.includes('D-') || firstCell.includes('Set-'))) {
        // Save previous set if exists
        if (currentSet && Object.keys(currentSetData).length > 0) {
          result.sets[currentSet] = { ...currentSetData };
        }
        
        currentSet = firstCell;
        currentSetData = {};
        console.log(`üìä Found set: ${currentSet}`);
        continue;
      }
      
      // Skip planet header rows (x, Sun, Moon, Mars, etc.)
      if (firstCell.toLowerCase() === 'x' || 
          ['sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
          .some(planet => firstCell.toLowerCase().includes(planet))) {
        console.log(`ü™ê Skipping planet header row: ${firstCell}`);
        continue;
      }
      
      // Process element rows (as, mo, hl, gl, etc.)
      if (currentSet && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        
        if (elementNames[elementCode]) {
          const elementName = elementNames[elementCode];
          const planetData = {};
          
          // Extract data for each planet column (columns 1-9)
          for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
            const cellValue = row[colIndex];
            if (cellValue && typeof cellValue === 'string' && cellValue.trim()) {
              const planetCode = planetMapping[colIndex];
              planetData[planetCode] = cellValue.trim();
            }
          }
          
          if (Object.keys(planetData).length > 0) {
            currentSetData[elementName] = planetData;
            console.log(`  üìù ${elementName}: ${Object.keys(planetData).length} planets`);
          }
        }
      }
    }
    
    // Save the last set
    if (currentSet && Object.keys(currentSetData).length > 0) {
      result.sets[currentSet] = { ...currentSetData };
    }
    
    console.log(`‚úÖ Processed ${Object.keys(result.sets).length} sets for ${targetDate}`);
    console.log('üìã Sets found:', Object.keys(result.sets));
    
    return result;
  };

  // Strict Excel validation function
  const validateStrictExcelData = (rows) => {
    console.log('üîç Starting strict Excel validation...');
    
    // Required elements in exact order
    const requiredElements = [
      'Lagna',
      'Moon', 
      'Hora Lagna',
      'Ghati Lagna',
      'Vighati Lagna',
      'Varnada Lagna',
      'Sree Lagna',
      'Pranapada Lagna',
      'Indu Lagna'
    ];
    
    // Element code mapping
    const elementCodeToName = {
      'as': 'Lagna',
      'mo': 'Moon',
      'hl': 'Hora Lagna', 
      'gl': 'Ghati Lagna',
      'vig': 'Vighati Lagna',
      'var': 'Varnada Lagna',
      'sl': 'Sree Lagna',
      'pp': 'Pranapada Lagna',
      'in': 'Indu Lagna'
    };
    
    const errors = [];
    let currentTopicIndex = -1;
    let elementIndex = 0;
    let inTopic = false;
    let topicsFound = 0;
    
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!Array.isArray(row) || row.length === 0) continue;
      
      const firstCell = String(row[0] || '').trim();
      
      // Check for topic header (D-x Set-y Matrix)
      if (firstCell.includes('Matrix') && firstCell.match(/D-\d+\s+Set-\d+\s+Matrix/)) {
        console.log(`‚úÖ Found valid topic header: ${firstCell}`);
        
        if (inTopic && elementIndex < requiredElements.length) {
          errors.push(`Topic "${rows[currentTopicIndex][0]}" is incomplete. Expected ${requiredElements.length} elements, found ${elementIndex}`);
        }
        
        currentTopicIndex = i;
        elementIndex = 0;
        inTopic = true;
        topicsFound++;
        continue;
      }
      
      // If we're in a topic, validate element rows
      if (inTopic && firstCell && firstCell.length <= 3) {
        const elementCode = firstCell.toLowerCase();
        const expectedElementName = elementCodeToName[elementCode];
        
        if (!expectedElementName) {
          // Skip non-element rows (like planet headers)
          if (['x', 'sun', 'moon', 'mars', 'mercury', 'jupiter', 'venus', 'saturn', 'rahu', 'ketu']
              .some(header => firstCell.toLowerCase().includes(header.toLowerCase()))) {
            continue;
          }
          errors.push(`Row ${i + 1}: Invalid element code "${elementCode}"`);
          continue;
        }
        
        // Check if element is in correct order
        if (elementIndex >= requiredElements.length) {
          errors.push(`Row ${i + 1}: Too many elements in topic. Expected only ${requiredElements.length} elements`);
          continue;
        }
        
        const expectedElement = requiredElements[elementIndex];
        if (expectedElementName !== expectedElement) {
          errors.push(`Row ${i + 1}: Element out of order. Expected "${expectedElement}", found "${expectedElementName}"`);
        }
        
        // Validate planet data in columns B-J (indices 1-9)
        let hasValidData = false;
        for (let colIndex = 1; colIndex <= 9 && colIndex < row.length; colIndex++) {
         