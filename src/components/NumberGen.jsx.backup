import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import Select from 'react-select';
import NumberGenTable from './NumberGenTable';
import DataSyncStatus from './DataSyncStatus';

// Add access to Electron IPC if it exists (will be undefined in web-only mode)
const electron = window.electron;

/**
 * NumberGen Component
 * Generates number combinations for selected planets based on three logics:
 * 1. Value Input Range (1-100) - Only includes numbers <= specified range
 * 2. Planet Selection (1-9 Planets) - User selects which planets to include
 * 3. Hierarchical Cycling - Generates combinations with decreasing row counts
 * 
 * Features:
 * - Multi-select planet functionality for each position
 * - Table shows specific planets used for each number combination
 * - Generates appropriate permutations of planets first, then corresponding numbers
 * 
 * Special case handling for Mars, Saturn, Kethu combinations (in any order)
 */

// Helper function to detect if running on an Apple platform
const isApplePlatform = () => {
  // First try to use Electron's platform info if available
  if (window.electron && window.electron.platform) {
    return window.electron.platform.isMac;
  }
  
  // Fallback to user agent detection for web browser
  const userAgent = window.navigator.userAgent.toLowerCase();
  return /macintosh|mac os x|iphone|ipad|ipod/.test(userAgent);
};

// Create initial range filter configuration
const createInitialRangeFilters = () => {
  return Array.from({ length: 10 }, (_, index) => {
    const min = index * 10 + 1;
    const max = (index + 1) * 10;
    return {
      id: `range-${min}-${max}`,
      min,
      max,
      active: false,
      inputValue: 0,
      matchCount: 0 // To track how many combinations match this range
    };
  });
};

const NumberGen = () => {
  // Strict maximum for all generation
  const STRICT_MAX_COMBINATIONS = 5000;
  console.log("Loading NumberGen component - " + new Date().toISOString());

  const planetNumbers = {
    Sun: [1, 10, 19, 28, 37, 46, 55, 64, 73, 82, 91, 100],
    Moon: [2, 11, 20, 29, 38, 47, 56, 65, 74, 83, 92],
    Mars: [9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99],
    Mercury: [5, 14, 23, 32, 41, 50, 59, 68, 77, 86, 95],
    Jupiter: [3, 12, 21, 30, 39, 48, 57, 66, 75, 84, 93],
    Venus: [6, 15, 24, 33, 42, 51, 60, 69, 78, 87, 96],
    Saturn: [8, 17, 26, 35, 44, 53, 62, 71, 80, 89, 98],
    Rahu: [4, 13, 22, 31, 40, 49, 58, 67, 76, 85, 94],
    Kethu: [7, 16, 25, 34, 43, 52, 61, 70, 79, 88, 97]
  };

  // State variables
  const [planetCount, setPlanetCount] = useState('');
  const [selectedPlanetsByPosition, setSelectedPlanetsByPosition] = useState([]); // This will now hold arrays of planets
  const [tableResults, setTableResults] = useState([]); // Will now contain objects with numbers and planets
  // User-configurable maxCombinations with unlimited option
  const [maxCombinations, setMaxCombinations] = useState(500); // Default 500, but user can change
  const [unlimitedMode, setUnlimitedMode] = useState(false); // Toggle for unlimited combinations
  const [valueRange, setValueRange] = useState(''); // Value range (1-100)
  const [minSum, setMinSum] = useState(''); // Minimum sum filter (1-500)
  const [maxSum, setMaxSum] = useState(''); // Maximum sum filter (1-500)
  const [rangeFilters, setRangeFilters] = useState(createInitialRangeFilters());
  const [filteredResults, setFilteredResults] = useState([]);
  const [isRangeFilteringActive, setIsRangeFilteringActive] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  // Format planet options for react-select
  const planetSelectOptions = Object.keys(planetNumbers).map(planet => ({
    value: planet,
    label: planet
  }));
  
  // Keep the original planetOptions array for compatibility
  const planetOptions = Object.keys(planetNumbers);

  // Initialize planet selectors without default values
  useEffect(() => {
    // Start with an empty array - no planets selected
    setSelectedPlanetsByPosition([]);

    Object.entries(planetNumbers).forEach(([planet, numbers]) => {
      console.log(`${planet} has ${numbers.length} numbers:`, numbers);
    });
  }, []);

  // Automatically populate planet selectors when planet count changes
  useEffect(() => {
    const numPlanetCount = Number(planetCount);

    if (isNaN(numPlanetCount) || numPlanetCount <= 0) {
      // If planet count is invalid, clear selections
      setSelectedPlanetsByPosition([]);
      return;
    }

    // Ensure we have arrays for the correct number of positions
    const newSelectedPlanets = Array(numPlanetCount).fill(null).map((_, index) => {
      // Keep existing selections if they exist, otherwise start with empty array
      return selectedPlanetsByPosition[index] || [];
    });

    console.log('Updated planet selections for', numPlanetCount, 'planets:', newSelectedPlanets);
    setSelectedPlanetsByPosition(newSelectedPlanets);
  }, [planetCount]);

  // Apple platform styling hook
  useEffect(() => {
    if (isApplePlatform()) {
      // Add an extra class to inputs for Apple styling if running on Apple platform
      const numericInputs = document.querySelectorAll('input[type="number"]');
      numericInputs.forEach(input => {
        input.classList.add('apple-input');
        
        // Add special handling for Apple numeric keyboards
        input.addEventListener('focus', () => {
          // On Apple devices, select all text when focusing on input
          setTimeout(() => input.select(), 10);
        });
      });
      
      // Add Apple-specific styles
      const style = document.createElement('style');
      style.innerHTML = `
        .apple-input::-webkit-inner-spin-button,
        .apple-input::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        
        .apple-input {
          -webkit-appearance: none;
          appearance: textfield;
        }
      `;
      document.head.appendChild(style);
      
      // Return cleanup function
      return () => {
        document.head.removeChild(style);
      };
    }
  }, []);

  // Generate Apple-specific button classes for styling
  const getButtonClass = (type) => {
    // Use the isApplePlatform helper to determine appropriate styling
    const baseClass = "px-6 py-3 text-lg font-semibold rounded-full shadow-md";
    const appleDevice = isApplePlatform();
    
    // Apply Apple-specific styling if running on macOS or iOS
    if (type === 'generate') {
      return appleDevice
        ? `${baseClass} bg-blue-500 text-white hover:bg-blue-600`
        : `${baseClass} bg-green-500 text-white hover:bg-green-600`;
    } else if (type === 'reset') {
      return appleDevice
        ? `${baseClass} bg-gray-200 text-gray-800 hover:bg-gray-300`
        : `${baseClass} bg-red-100 text-red-800 hover:bg-red-200`;
    }
    
    return baseClass;
  };

  const handlePlanetChange = (index, selectedOptions) => {
    console.log(`Planet Change for index ${index}:`, selectedOptions);
    const newSelectedPlanets = [...selectedPlanetsByPosition];
    newSelectedPlanets[index] = selectedOptions ? selectedOptions.map(option => option.value) : [];
    console.log('New planet selection state:', newSelectedPlanets);
    setSelectedPlanetsByPosition(newSelectedPlanets);
  };

  const generateTableNumbers = () => {
    // Estimate total combinations before generating
    const estimateTotalCombinations = () => {
      if (!selectedPlanetsByPosition || selectedPlanetsByPosition.length === 0) return 0;
      return selectedPlanetsByPosition.reduce((acc, arr) => acc * (arr ? arr.length : 0), 1);
    };
    const estimated = estimateTotalCombinations();
    if (estimated > STRICT_MAX_COMBINATIONS) {
      alert(`Too many combinations (${estimated}). Please reduce your selections or filters. Maximum allowed is ${STRICT_MAX_COMBINATIONS}.`);
      return;
    }
    console.log('=== GENERATE TABLE NUMBERS STARTED ===');
    console.log('Planet count:', planetCount);
    console.log('Value range:', valueRange);
    console.log('Min sum:', minSum, 'Max sum:', maxSum);
    console.log('selectedPlanetsByPosition length:', selectedPlanetsByPosition.length);
    console.log('selectedPlanetsByPosition:', selectedPlanetsByPosition);
    
    console.log('Generating combinations from selected planets');
    console.log('Selected planets:', selectedPlanetsByPosition);
    console.log('Value range:', valueRange);
    console.log('Sum range filter:', `${minSum} to ${maxSum}`);
    
    // Handle empty values with default validation values for generation only
    const minSumNum = minSum === '' ? 1 : Number(minSum);
    const maxSumNum = maxSum === '' ? 150 : Number(maxSum);
    
    // Validate inputs
    if (isNaN(minSumNum) || isNaN(maxSumNum)) {
      alert('Error: Sum range values must be valid numbers');
      return;
    }
    
    // Handle empty value range
    if (valueRange === '') {
      console.log('VALIDATION FAILED: Empty value range');
      alert('Please enter a Value Range before generating combinations');
      return;
    }
    
    // Handle empty planet count
    if (planetCount === '') {
      console.log('VALIDATION FAILED: Empty planet count');
      alert('Please enter the Number of Planets before generating combinations');
      return;
    }
    
    // Check if all planet selectors have at least one selection
    console.log('Checking for empty positions...');
    const emptyPositions = selectedPlanetsByPosition
      .map((planets, index) => ({ position: index + 1, planets }))
      .filter(pos => !pos.planets || pos.planets.length === 0);
    
    console.log('Empty positions found:', emptyPositions);
    
    if (emptyPositions.length > 0) {
      const emptyPositionNumbers = emptyPositions.map(pos => pos.position).join(', ');
      console.log('VALIDATION FAILED: Empty positions at:', emptyPositionNumbers);
      alert(`Please select at least one planet for position(s): ${emptyPositionNumbers}`);
      return;
    }
    
    console.log('VALIDATION PASSED: All positions have planets selected');
    
    // Ensure minSum is not greater than maxSum
    if (minSumNum > maxSumNum) {
      alert('Error: Minimum sum cannot be greater than maximum sum');
      return;
    }
    
    // Update state with validated numbers
    setMinSum(minSumNum);
    setMaxSum(maxSumNum);

    // Progressive rendering and loading indicator
    setIsLoading(true);
    setTableResults([]);
    setFilteredResults([]);
    
    const planetPermutations = generatePlanetPermutations();
    if (planetPermutations.length === 0) {
      alert('No combinations possible. Please ensure all planet positions have at least one planet selected.');
      setIsLoading(false);
      return;
    }
    
    let allResults = [];
    let batchSize = 100;
    let batchIndex = 0;
    
    function processBatch() {
      try {
        const end = Math.min(batchIndex + batchSize, planetPermutations.length);
        for (let i = batchIndex; i < end; i++) {
          const permutation = planetPermutations[i];
          const planetsWithNumbers = permutation.map((planet) => ({
            planet: planet,
            numbers: planetNumbers[planet]
          }));
          const permResult = findCombinationsFromPlanetNumbers(planetsWithNumbers, permutation);
          allResults = [...allResults, ...permResult];
        }
        // Sort and limit results
        allResults.sort((a, b) => {
          for (let i = 0; i < a.numbers.length; i++) {
            if (a.numbers[i] !== b.numbers[i]) return a.numbers[i] - b.numbers[i];
          }
          return 0;
        });
        allResults = allResults.slice(0, STRICT_MAX_COMBINATIONS);
        setTableResults([...allResults]);
        setFilteredResults(applyRangeFilters(allResults));
        batchIndex = end;
        if (batchIndex < planetPermutations.length && allResults.length < STRICT_MAX_COMBINATIONS) {
          setTimeout(processBatch, 0);
        } else {
          setIsLoading(false);
        }
      } catch (error) {
        setIsLoading(false);
        alert("There was an error generating combinations. Please try with different planets.");
      }
    }
    processBatch();
  };

  const findCombinationsFromPlanetNumbers = (planetsWithNumbers, sourcePlanets) => {
    const results = [];
    
    const generateCombinations = (currentIndex, currentCombination, currentSum, filteredPlanets) => {
      if (currentIndex >= filteredPlanets.length) {
        return;
      }
      
      const currentPlanet = filteredPlanets[currentIndex];
      // MODIFIED: For left-to-right ascending ordering, get previous number for comparison
      const prevNumber = currentIndex > 0 ? currentCombination[currentIndex - 1] : -Infinity;
      
      // Calculate the minimum possible sum for remaining planets (optimization)
      let minPossibleSum = currentSum;
      let remainingMinValues = 0;
      for (let j = currentIndex + 1; j < filteredPlanets.length; j++) {
        remainingMinValues += Math.min(...filteredPlanets[j].numbers);
      }
      minPossibleSum += remainingMinValues;
      
      for (let numberIndex = 0; numberIndex < currentPlanet.numbers.length; numberIndex++) {
        const number = currentPlanet.numbers[numberIndex];
        
        // MODIFIED: Changed from >= (non-decreasing) to > (strictly ascending)
        if (number > prevNumber && number <= valueRange) {
          const newSum = currentSum + number;
          const newCombination = [...currentCombination, number];
          
          if (currentIndex === filteredPlanets.length - 1) {
            // This is the last planet
            if (newSum >= minSum && newSum <= maxSum) {
              results.push({
                numbers: newCombination,
                planets: sourcePlanets
              });
            }
          } else {
            // Recurse for next planet
            generateCombinations(currentIndex + 1, newCombination, newSum, filteredPlanets);
          }
        }
      }
    };
    
    generateCombinations(0, [], 0, planetsWithNumbers);

    // Sort results for LEFT-TO-RIGHT ascending ordering
    results.sort((a, b) => {
      for (let i = 0; i < a.numbers.length; i++) {
        if (a.numbers[i] !== b.numbers[i]) {
          // For the first planet that differs, sort by its number in ascending order
          return a.numbers[i] - b.numbers[i];
        }
      }
      return 0; // If all numbers are the same
    });
    
    console.log('Sorted results based on LEFT-TO-RIGHT position hierarchy (POSITION-BASED ORDER):', results);
    console.log('Sample combinations (POSITION-BASED planets, LEFT-TO-RIGHT ascending numbers):');
    if (results.length > 0) {
      results.slice(0, 5).forEach((result, index) => {
        console.log(`  ${index + 1}: [${result.numbers.join(', ')}] - planets: [${result.planets.join(', ')}]`);
      });
    }
    return results;
  };

  // Helper function to get a nice display name for planets
  const getDisplayNameForPlanet = (planet) => {
    // Map of shortened planet names to their full names
    const planetDisplayNames = {
      'Sun': 'Sun',
      'Moon': 'Moon',
      'Mars': 'Mars',
      'Mercury': 'Mercury',
      'Jupiter': 'Jupiter',
      'Venus': 'Venus',
      'Saturn': 'Saturn',
      'Rahu': 'Rahu',
      'Kethu': 'Kethu'
    };
    
    return planetDisplayNames[planet] || planet;
  };
  
  const resetFilters = () => {
    setTableResults([]);
    setFilteredResults([]);
    setValueRange('');
    setMinSum('');
    setMaxSum('');
    setPlanetCount(''); // Reset planet count to empty
    setRangeFilters(createInitialRangeFilters());
    setIsRangeFilteringActive(false);
    
    // If running in Electron, update the settings in the main process
    if (electron) {
      electron.send('update-number-settings', {
        valueRange: '',
        minSum: '',
        maxSum: '',
        planetCount: '',
        rangeFilters: createInitialRangeFilters()
      });
    }
  };
  
  // Apply range filters to combinations
  const applyRangeFilters = (combinations) => {
    // Check if any range filters are active
    const hasActiveFilters = rangeFilters.some(range => range.active);
    setIsRangeFilteringActive(hasActiveFilters);
    
    if (!hasActiveFilters) {
      // If no filters are active, return all combinations
      return combinations;
    }

    // Calculate match statistics for each range
    const updatedRangeFilters = rangeFilters.map(range => {
      // Count how many combinations would be excluded by this filter
      let matchCount = 0;
      
      // Go through each combination
      for (const combo of combinations) {
        // Count how many numbers in this combination fall within the current range
        const numbersInRange = combo.numbers.filter(n => n >= range.min && n <= range.max).length;
        
        // If the range filter is active and the condition is met, exclude this combination
        if (range.active && numbersInRange >= Number(range.inputValue)) {
          // This combination would be excluded, don't count it
        } else {
          // This combination would pass the filter
          matchCount++;
        }
      }
      
      return { ...range, matchCount };
    });
    
    // Update range filters with new match counts
    setRangeFilters(updatedRangeFilters);
    
    // Apply all active filters
    return combinations.filter(combo => {
      // For each active filter, check if this combination should be excluded
      for (const range of rangeFilters) {
        if (range.active) {
          const numbersInRange = combo.numbers.filter(n => n >= range.min && n <= range.max).length;
          if (numbersInRange >= Number(range.inputValue)) {
            // This combination is excluded by this filter
            return false;
          }
        }
      }
      // Combination passes all filters
      return true;
    });
  };

  const toggleRangeFilter = (filterId) => {
    const newRangeFilters = rangeFilters.map(range => 
      range.id === filterId ? { ...range, active: !range.active } : range
    );
    setRangeFilters(newRangeFilters);
    
    // Re-apply filters with updated state
    const filtered = applyRangeFilters(tableResults);
    setFilteredResults(filtered);
  };
  
  const updateRangeFilterValue = (filterId, value) => {
    const newRangeFilters = rangeFilters.map(range => 
      range.id === filterId ? { ...range, inputValue: value } : range
    );
    setRangeFilters(newRangeFilters);
    
    // Re-apply filters with updated state
    const filtered = applyRangeFilters(tableResults);
    setFilteredResults(filtered);
  };
  
  const disableAllRangeFilters = () => {
    const newRangeFilters = rangeFilters.map(range => ({ ...range, active: false }));
    setRangeFilters(newRangeFilters);
    setIsRangeFilteringActive(false);
    setFilteredResults(tableResults); // Show all results when no filters are active
  };
  
  const setAllRangeFiltersTo = (value) => {
    const newRangeFilters = rangeFilters.map(range => ({ 
      ...range, 
      inputValue: value,
      active: range.active // Keep current active state
    }));
    setRangeFilters(newRangeFilters);
    
    // Re-apply filters with updated values
    const filtered = applyRangeFilters(tableResults);
    setFilteredResults(filtered);
  };

  // Cartesian product helper function for generating all combinations
  const cartesianProduct = (arrays) => {
    if (arrays.length === 0) return [[]];
    
    const [first, ...rest] = arrays;
    const restProduct = cartesianProduct(rest);
    
    return first.flatMap(item => 
      restProduct.map(combo => [item, ...combo])
    );
  };

  const generatePlanetPermutations = () => {
    console.log('=== GENERATE PLANET PERMUTATIONS ===');
    console.log('Selected planets by position:', selectedPlanetsByPosition);
    
    // Filter out any empty positions
    const validPlanetSelections = selectedPlanetsByPosition.filter(planets => 
      planets && planets.length > 0
    );
    
    console.log('Valid planet selections (non-empty positions):', validPlanetSelections);
    
    if (validPlanetSelections.length === 0) {
      console.warn('No valid planet selections found');
      return [];
    }
    
    // Check for empty positions
    const emptyPositions = selectedPlanetsByPosition
      .map((planets, index) => ({ planets, index }))
      .filter(pos => !pos.planets || pos.planets.length === 0);
    
    if (emptyPositions.length > 0) {
      console.warn('Empty planet selections found at positions:', 
        emptyPositions.map(pos => pos.index + 1));
      return [];
    }
    
    // Calculate total possible combinations
    const totalPossibleCombos = selectedPlanetsByPosition.reduce(
      (acc, planets) => acc * (planets.length || 1), 1
    );
    console.log(`Total possible planet permutations: ${totalPossibleCombos}`);
    
    // Return all permutations (cartesian product) and maintain position-based order
    const permutations = cartesianProduct(selectedPlanetsByPosition);
    
    // FIXED: Keep original position-based order instead of sorting alphabetically
    // Each permutation maintains the user's intended planet-to-position mapping
    console.log('Generated permutations (maintaining position-based order):');
    permutations.forEach((perm, index) => {
      if (index < 5) { // Only log first 5 for brevity
        console.log(`  Permutation ${index + 1}: [${perm.join(', ')}] (Position 1: ${perm[0]}, Position 2: ${perm[1]}, etc.)`);
      }
    });
    
    console.log(`Generated ${permutations.length} planet permutations (POSITION-BASED ORDER)`);
    console.log('NOTE: Each position maintains its selected planet (no alphabetical sorting)');
    
    return permutations;
  };

  // Main JSX return for NumberGen component
  return (
    <div className="container mx-auto px-4 py-8 max-w-6xl">
      {isLoading && (
        <div className="fixed top-0 left-0 w-full h-full flex items-center justify-center bg-white bg-opacity-60 z-50">
          <div className="p-6 bg-blue-100 rounded shadow text-blue-800 font-bold text-xl animate-pulse">
            Generating combinations... Please wait
          </div>
        </div>
      )}
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-3xl font-bold text-gray-800">Number Generator</h1>
        <div className="flex gap-2">
          <Link 
            to="/users" 
            className="px-4 py-2 bg-gray-100 text-gray-800 rounded hover:bg-gray-200"
          >
            Back to Users
          </Link>
        </div>
      </div>

      {/* Add DataSyncStatus component */}
      <DataSyncStatus />

      <div className="bg-white rounded-lg shadow-md p-6 mb-6">
        {/* Settings Section */}
        <div className="flex flex-col md:flex-row border-2 border-blue-500 rounded-md p-4 mb-4">
          <div className="w-full md:w-1/2 p-2">
            <h3 className="font-bold text-lg mb-2">Number of Planets (1-9)</h3>
            <input
              type="number"
              min="1"
              max="9"
              className="w-full border-2 border-green-500 rounded p-2"
              value={planetCount}
              onChange={(e) => {
                // Allow empty string value
                if (e.target.value === '') {
                  setPlanetCount('');
                  return;
                }
                const value = Number(e.target.value);
                setPlanetCount(Math.max(1, Math.min(9, value)));
              }}
            />
          </div>
          <div className="w-full md:w-1/2 p-2">
            <h3 className="font-bold text-lg mb-2">Value Range (1-100)</h3>
            <input
              type="number"
              min="1"
              max="100"
              className="w-full border-2 border-green-500 rounded p-2"
              value={valueRange}
              onChange={(e) => {
                // Allow empty string value
                if (e.target.value === '') {
                  setValueRange('');
                  return;
                }
                const value = Number(e.target.value);
                setValueRange(Math.max(1, Math.min(100, value)));
              }}
            />
          </div>
        </div>
        
        {/* Sum Filter Section */}
        <div className="flex flex-col md:flex-row border-2 border-blue-500 rounded-md p-4 mb-4">
          <div className="w-full md:w-1/2 p-2">
            <h3 className="font-bold text-lg mb-2">Minimum Sum</h3>
            <input
              type="number"
              min="0"
              max="500"
              className="w-full border-2 border-green-500 rounded p-2"
              value={minSum}
              onChange={(e) => {
                // Allow empty string for Apple's input handling
                if (e.target.value === '') {
                  setMinSum('');
                  return;
                }
                
                const value = Number(e.target.value);
                // Use null coalescing to handle NaN values
                const sanitizedValue = isNaN(value) ? 0 : value;
                // Allow any value between 0 and 500
                setMinSum(Math.min(500, Math.max(0, sanitizedValue)));
              }}
              // Handle blur to ensure we have a valid number when focus leaves
              onBlur={() => {
                if (isNaN(Number(minSum)) && minSum !== '') {
                  setMinSum('');
                }
              }}
            />
          </div>
          <div className="w-full md:w-1/2 p-2">
            <h3 className="font-bold text-lg mb-2">Maximum Sum</h3>
            <input
              type="number"
              min="0"
              max="500"
              className="w-full border-2 border-green-500 rounded p-2"
              value={maxSum}
              onChange={(e) => {
                // Allow empty string for Apple's input handling
                if (e.target.value === '') {
                  setMaxSum('');
                  return;
                }
                
                const value = Number(e.target.value);
                // Use null coalescing to handle NaN values
                const sanitizedValue = isNaN(value) ? 0 : value;
                // Allow any value between 0 and 500
                setMaxSum(Math.min(500, Math.max(0, sanitizedValue)));
              }}
              // Handle blur to ensure we have a valid number when focus leaves
              onBlur={() => {
                if (isNaN(Number(maxSum)) && maxSum !== '') {
                  setMaxSum('');
                }
              }}
            />
          </div>
        </div>
        
        {/* Max Combinations Control Section */}
        <div className="flex flex-col md:flex-row border-2 border-purple-500 rounded-md p-4 mb-4 bg-purple-50">
          <div className="w-full md:w-1/2 p-2">
            <h3 className="font-bold text-lg mb-2 text-purple-800">Maximum Combinations</h3>
            <div className="flex items-center gap-2 mb-3">
              <input
                type="checkbox"
                id="unlimitedMode"
                checked={unlimitedMode}
                onChange={(e) => setUnlimitedMode(e.target.checked)}
                className="w-4 h-4 text-purple-600"
              />
              <label htmlFor="unlimitedMode" className="text-sm font-medium text-purple-700">
                Unlimited Mode (Generate all possible combinations)
              </label>
            </div>
            {!unlimitedMode && (
              <input
                type="number"
                min="1"
                max="10000"
                className="w-full border-2 border-purple-500 rounded p-2"
                value={maxCombinations}
                onChange={(e) => {
                  const value = Number(e.target.value);
                  if (value > 0) {
                    setMaxCombinations(value);
                  }
                }}
                placeholder="Enter max combinations (e.g., 500, 1000)"
              />
            )}
          </div>
          <div className="w-full md:w-1/2 p-2">
            <h3 className="font-bold text-lg mb-2 text-purple-800">Supercomputer Mode</h3>
            <div className="text-sm text-purple-700 space-y-1">
              <p>ðŸš€ <strong>High-performance calculations</strong> for instant results</p>
              <p>âš¡ Optimized for heavy computational workloads</p>
              <p>ï¿½ Robust capability for complex combinations</p>
              {unlimitedMode && (
                <p className="text-green-600 font-semibold">ï¿½ UNLIMITED MODE ACTIVE - Maximum power unleashed!</p>
              )}
            </div>
          </div>
        </div>
        
        {/* Planet Selector Section */}
        <div className="border-2 border-blue-500 rounded-md overflow-hidden mb-4">
          <div className="flex flex-wrap">
            {Number(planetCount) > 0 ? 
              Array.from({ length: Number(planetCount) }).map((_, index) => (
                <div key={index} className="w-full sm:w-1/2 md:w-1/3 lg:w-1/4 xl:w-auto border-b border-r border-blue-300 last:border-r-0">
                  <div className="bg-blue-100 p-2 text-center font-semibold border-b border-blue-300">
                    Planet {index + 1}
                  </div>
                  <div className="p-2 bg-teal-100">
                    <Select
                      isMulti
                      className="planet-select"
                      placeholder="Select planets..."
                      options={planetSelectOptions}
                      value={selectedPlanetsByPosition[index]?.map(value => 
                        planetSelectOptions.find(opt => opt.value === value)
                      ) || []}
                      onChange={(selectedOptions) => handlePlanetChange(index, selectedOptions)}
                      styles={{
                        control: (base) => ({
                          ...base,
                          borderColor: '#4ade80',
                          '&:hover': { borderColor: '#16a34a' },
                        }),
                        multiValue: (base) => ({
                          ...base,
                          backgroundColor: '#d1fae5',
                        }),
                        multiValueLabel: (base) => ({
                          ...base,
                          color: '#065f46',
                          fontWeight: 500,
                        })
                      }}
                    />
                  </div>
                </div>
              )) : null
            }
          </div>
        </div>
        
        {/* Multi-Range Filter Section */}
        <div className="border-2 border-blue-500 rounded-md p-4 mb-4">
          <div className="flex flex-row justify-between items-center mb-4">
            <h3 className="font-bold text-lg">Number Range Filters</h3>
            <div className="flex gap-2">
              <button 
                onClick={disableAllRangeFilters}
                className="px-3 py-1 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 text-sm"
              >
                Disable All
              </button>
              <div className="flex items-center gap-2">
                <span className="text-sm">Set All To:</span>
                <select 
                  className="border rounded px-2 py-1"
                  onChange={(e) => setAllRangeFiltersTo(e.target.value)}
                >
                  {[0,1,2,3,4,5,6].map(num => (
                    <option key={num} value={num}>{num}</option>
                  ))}
                </select>
              </div>
            </div>
          </div>

          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 lg:grid-cols-5 gap-3">
            {rangeFilters.map((range) => (
              <div 
                key={range.id} 
                className={`border p-3 rounded-md ${range.active ? 'bg-blue-50 border-blue-400' : 'bg-gray-50 border-gray-300'}`}
              >
                <div className="flex justify-between items-center mb-2">
                  <label className="font-medium text-sm">{range.min}-{range.max}</label>
                  <button 
                    onClick={() => toggleRangeFilter(range.id)}
                    className={`w-8 h-5 rounded-full flex items-center transition-all duration-300 ${range.active ? 'bg-blue-500 justify-end' : 'bg-gray-300 justify-start'}`}
                  >
                    <span className="block w-4 h-4 bg-white rounded-full shadow mx-0.5"></span>
                  </button>
                </div>

                <div className="flex items-center gap-2">
                  <input 
                    type="number" 
                    min="0" 
                    max="6" 
                    className={`w-full border rounded p-1 text-center ${!range.active && 'opacity-50'}`}
                    value={range.inputValue} 
                    onChange={(e) => updateRangeFilterValue(range.id, e.target.value)}
                    disabled={!range.active}
                    title={`Exclude combinations with this many or more numbers in ${range.min}-${range.max} range`}
                  />
                  <span className="text-xs text-gray-500">{tableResults.length > 0 ? `${range.matchCount}/${tableResults.length}` : '0/0'}</span>
                </div>
              </div>
            ))}
          </div>

          {isRangeFilteringActive && tableResults.length > 0 && (
            <div className="mt-3 p-2 bg-blue-50 border border-blue-200 rounded-md text-sm">
              <p className="font-medium">
                Showing {filteredResults.length} of {tableResults.length} combinations after range filtering
              </p>
              <p className="text-xs text-gray-600 mt-1">
                Each number represents the count of numbers to exclude combinations from that range
              </p>
            </div>
          )}
        </div>
        
        {/* Controls */}
        <div className="flex flex-col md:flex-row items-center justify-center gap-4 mb-6">
          <button
            className={getButtonClass('generate')}
            onClick={() => {
              console.log('Generate button clicked');
              generateTableNumbers();
            }}
          >
            Generate Combinations
          </button>
          
          <button
            className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600"
            onClick={() => {
              console.log('=== DEBUG STATE ===');
              console.log('Planet Count:', planetCount);
              console.log('Value Range:', valueRange);
              console.log('Min Sum:', minSum);
              console.log('Max Sum:', maxSum);
              console.log('Selected Planets by Position:', selectedPlanetsByPosition);
              console.log('selectedPlanetsByPosition.length:', selectedPlanetsByPosition.length);
              
              // Check for empty positions like the validation does
              const emptyPositions = selectedPlanetsByPosition
                .map((planets, index) => ({ position: index + 1, planets }))
                .filter(pos => !pos.planets || pos.planets.length === 0);
              console.log('Empty positions (debug check):', emptyPositions);
              
              console.log('Table Results Length:', tableResults.length);
              console.log('=== END DEBUG ===');
              
              alert(`Debug info logged to console. Empty positions: ${emptyPositions.length > 0 ? emptyPositions.map(p => p.position).join(', ') : 'None'}`);
            }}
          >
            Debug State
          </button>
          
          <button
            className={getButtonClass('reset')}
            onClick={resetFilters}
          >
            Reset All Filters
          </button>
        </div>
        
        {/* Results Section - Always show the table component */}
        <NumberGenTable
          combinations={tableResults && tableResults.length > 0 ? (isRangeFilteringActive ? filteredResults : tableResults) : []}
          onDeleteCombination={() => {}} // Add empty handler for now
          onClearAll={() => setTableResults([])} // Add clear all handler
        />
        
        {/* No Results Message - Show when results are empty after generation attempt */}
        {tableResults && tableResults.length === 0 && planetCount && valueRange && (
          <div className="text-center py-8">
            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
              <h3 className="text-lg font-medium text-yellow-800 mb-2">No Combinations Generated</h3>
              <p className="text-yellow-700 mb-4">
                No valid combinations were found with the current settings.
              </p>
              <div className="text-sm text-yellow-600">
                <p>Possible reasons:</p>
                <ul className="list-disc list-inside mt-2 space-y-1">
                  <li>Not all planet positions have planets selected</li>
                  <li>The value range is too restrictive</li>
                  <li>The sum constraints (min/max) are too narrow</li>
                  <li>Selected planets don't have numbers that meet the criteria</li>
                </ul>
                <p className="mt-3 font-medium">Try:</p>
                <ul className="list-disc list-inside mt-1 space-y-1">
                  <li>Selecting planets for all positions</li>
                  <li>Increasing the value range</li>
                  <li>Adjusting the sum range</li>
                  <li>Using the Debug State button to check your selections</li>
                </ul>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default NumberGen;