<!DOCTYPE html>
<html>
<head>
    <title>Fetch Real Available Dates - Browser</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
</head>
<body>
    <h1>üîç FETCHING REAL AVAILABLE DATES FOR USER "sing maya"</h1>
    <div id="results"></div>

    <script>
        // Initialize Supabase with environment variables
        const supabaseUrl = 'https://lgbcbqaqdsgwkcgvqlsg.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxnYmNicWFxZHNnd2tjZ3ZxbHNnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzIxMDgyNTcsImV4cCI6MjA0NzY4NDI1N30.tKZgapYNcJOgXYbF8BhJJNKpI5WuEw6oc3vJYHhBFD0';
        
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
        
        const USER_ID = 'sing maya';
        const resultsDiv = document.getElementById('results');
        
        async function fetchAllAvailableDates() {
            resultsDiv.innerHTML = '<h2>üìä CHECKING ALL DATA SOURCES...</h2>';
            
            const allDates = new Set();
            let output = '';
            
            try {
                // 1. Check Excel Data
                output += '<h3>1Ô∏è‚É£ CHECKING EXCEL DATA...</h3>';
                const { data: excelData, error: excelError } = await supabase
                    .from('excel_data')
                    .select('date, file_name')
                    .eq('user_id', USER_ID)
                    .order('date', { ascending: true });
                
                if (excelError) {
                    output += `<p>‚ùå Excel data error: ${excelError.message}</p>`;
                } else {
                    output += `<p>‚úÖ Found ${excelData.length} Excel records:</p><ul>`;
                    excelData.forEach(record => {
                        output += `<li>üìä ${record.date} - ${record.file_name}</li>`;
                        allDates.add(record.date);
                    });
                    output += '</ul>';
                }
                
                // 2. Check Hour Entries
                output += '<h3>2Ô∏è‚É£ CHECKING HOUR ENTRIES...</h3>';
                const { data: hourData, error: hourError } = await supabase
                    .from('hour_entries')
                    .select('date_key, hour_data')
                    .eq('user_id', USER_ID)
                    .order('date_key', { ascending: true });
                
                if (hourError) {
                    output += `<p>‚ùå Hour entries error: ${hourError.message}</p>`;
                } else {
                    output += `<p>‚úÖ Found ${hourData.length} Hour Entry records:</p><ul>`;
                    hourData.forEach(record => {
                        const hrCount = Object.keys(record.hour_data?.planetSelections || {}).length;
                        output += `<li>‚è∞ ${record.date_key} - ${hrCount} hours</li>`;
                        allDates.add(record.date_key);
                    });
                    output += '</ul>';
                }
                
                // 3. Check User Dates
                output += '<h3>3Ô∏è‚É£ CHECKING USER DATES...</h3>';
                const { data: userData, error: userError } = await supabase
                    .from('user_dates')
                    .select('dates')
                    .eq('user_id', USER_ID)
                    .single();
                
                if (userError) {
                    output += `<p>‚ùå User dates error: ${userError.message}</p>`;
                } else if (userData?.dates) {
                    output += `<p>‚úÖ Found ${userData.dates.length} User Date records:</p><ul>`;
                    userData.dates.forEach(date => {
                        output += `<li>üìÖ ${date}</li>`;
                        allDates.add(date);
                    });
                    output += '</ul>';
                }
                
                // 4. Check ABCD User Dates
                output += '<h3>4Ô∏è‚É£ CHECKING ABCD USER DATES...</h3>';
                const { data: abcdUserData, error: abcdUserError } = await supabase
                    .from('user_dates_abcd')
                    .select('dates')
                    .eq('user_id', USER_ID)
                    .single();
                
                if (abcdUserError) {
                    output += `<p>‚ùå ABCD user dates error: ${abcdUserError.message}</p>`;
                } else if (abcdUserData?.dates) {
                    output += `<p>‚úÖ Found ${abcdUserData.dates.length} ABCD User Date records:</p><ul>`;
                    abcdUserData.dates.forEach(date => {
                        output += `<li>üìÖ ${date}</li>`;
                        allDates.add(date);
                    });
                    output += '</ul>';
                }
                
                // Combine and analyze all dates
                const sortedDates = Array.from(allDates).sort((a, b) => new Date(a) - new Date(b));
                
                output += '<h3>üéØ FINAL ANALYSIS:</h3>';
                output += `<p><strong>Total unique dates found:</strong> ${sortedDates.length}</p>`;
                output += `<p><strong>All available dates:</strong> ${sortedDates.join(', ')}</p>`;
                
                // Test N-1 pattern for July 7
                const july7 = '2025-07-07';
                const july7Date = new Date(july7);
                
                output += '<h3>üßÆ N-1 PATTERN ANALYSIS FOR JULY 7:</h3>';
                output += `<p><strong>Target date:</strong> ${july7}</p>`;
                
                // Find closest previous date
                let closestPrevious = null;
                for (let i = sortedDates.length - 1; i >= 0; i--) {
                    const availableDate = new Date(sortedDates[i]);
                    if (availableDate < july7Date) {
                        closestPrevious = sortedDates[i];
                        output += `<p>‚úÖ <strong>Found closest previous date:</strong> ${closestPrevious}</p>`;
                        break;
                    }
                }
                
                if (!closestPrevious) {
                    output += '<p>‚ùå No previous date found for July 7, 2025</p>';
                }
                
                // Dates that have BOTH Excel and Hour Entry data
                output += '<h3>üîÑ DATES WITH COMPLETE DATA (Excel + Hour Entry):</h3>';
                
                const completeDates = [];
                output += '<ul>';
                for (const date of sortedDates) {
                    const hasExcel = excelData.some(record => record.date === date);
                    const hasHour = hourData.some(record => record.date_key === date);
                    
                    if (hasExcel && hasHour) {
                        completeDates.push(date);
                        output += `<li>‚úÖ ${date} - COMPLETE (Excel ‚úì + Hour Entry ‚úì)</li>`;
                    } else {
                        output += `<li>‚ö†Ô∏è  ${date} - INCOMPLETE (Excel ${hasExcel ? '‚úì' : '‚ùå'} + Hour Entry ${hasHour ? '‚úì' : '‚ùå'})</li>`;
                    }
                }
                output += '</ul>';
                
                output += '<h3>üìã SUMMARY FOR N-1 PATTERN:</h3>';
                output += `<p><strong>Available dates:</strong> ${sortedDates}</p>`;
                output += `<p><strong>Complete dates:</strong> ${completeDates}</p>`;
                output += `<p><strong>July 7 ‚Üí Previous date:</strong> ${closestPrevious}</p>`;
                output += `<p><strong>Is closest previous complete?:</strong> ${completeDates.includes(closestPrevious)}</p>`;
                
                output += '<h3>üéØ CONCLUSION:</h3>';
                if (closestPrevious === '2025-06-30') {
                    output += '<p style="color: green; font-weight: bold;">‚úÖ THE SYSTEM IS WORKING CORRECTLY!</p>';
                    output += '<p>The N-1 pattern logic is correct:</p>';
                    output += '<ul>';
                    output += '<li>User clicked: July 7, 2025</li>';
                    output += '<li>N-1 target: July 6, 2025 (not available)</li>';
                    output += '<li>Fallback: June 30, 2025 (closest previous date)</li>';
                    output += '<li>Result: Analysis shows June 30 data ‚úì</li>';
                    output += '</ul>';
                    output += '<p><strong>The "issue" is that July 3rd data does not exist in the database!</strong></p>';
                } else {
                    output += '<p style="color: red; font-weight: bold;">‚ùå UNEXPECTED RESULT</p>';
                    output += `<p>Expected June 30, got: ${closestPrevious}</p>`;
                }
                
                resultsDiv.innerHTML = output;
                
            } catch (error) {
                resultsDiv.innerHTML = `<p style="color: red;">‚ùå Error fetching dates: ${error.message}</p>`;
                console.error('‚ùå Error fetching dates:', error);
            }
        }
        
        // Run the analysis when page loads
        fetchAllAvailableDates();
    </script>
</body>
</html>
