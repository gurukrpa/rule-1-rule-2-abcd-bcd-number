import{c as y,p as U}from"./main-B43Pc4Hw.js";class v{static async checkDateData(t,e){try{const o=await y.hasExcelData(t,e),s=await y.hasHourEntry(t,e);return{hasData:o&&s,hasExcel:o,hasHour:s}}catch(o){return console.error(`Error checking data for ${e}:`,o),{hasData:!1,hasExcel:!1,hasHour:!1,error:o.message}}}static async autoPopulateMissingDate(t,e){try{console.log(`üîß [DateManagement] Auto-populating ${e}...`);const o=await this.checkDateData(t,e);if(o.hasData)return{success:!0,message:`Date ${e} already has complete data`};const s=await y.getUserDates(t);if(s.length===0)return{success:!1,message:"No existing data found to use as template"};const u=s.sort((n,d)=>new Date(n)-new Date(d)),c=u[u.length-1];if(console.log(`üìã [DateManagement] Using ${c} as template for ${e}`),!o.hasExcel){const n=await y.getExcelData(t,c);if(n){const d={...n,upload_date:e,metadata:{...n.metadata,autoGenerated:!0,sourceDate:c,targetDate:e,createdAt:new Date().toISOString(),note:`Auto-generated from ${c} for seamless Planets Analysis`}};await y.saveExcelData(t,e,d),console.log(`‚úÖ [DateManagement] Excel data copied to ${e}`)}}if(!o.hasHour){const n=await y.getHourEntry(t,c);if(n){const d={...n,date:e,metadata:{...n.metadata,autoGenerated:!0,sourceDate:c,targetDate:e,createdAt:new Date().toISOString(),note:`Auto-generated from ${c} for seamless Planets Analysis`}};await y.saveHourEntry(t,e,d),console.log(`‚úÖ [DateManagement] Hour entry copied to ${e}`)}}return(await this.checkDateData(t,e)).hasData?{success:!0,message:`Successfully auto-populated ${e} using template from ${c}`}:{success:!1,message:`Failed to auto-populate ${e} - verification failed`}}catch(o){return console.error(`[DateManagement] Error auto-populating ${e}:`,o),{success:!1,message:`Error: ${o.message}`}}}static async checkSequenceData(t,e){const[o,s,u,c]=e,m={},n=[];for(const d of e){const h=await this.checkDateData(t,d);m[d]=h,h.hasData||n.push(d)}return{isComplete:n.length===0,missingDates:n,details:m}}static async autoFillSequence(t,e){try{const o=await this.checkSequenceData(t,e);if(o.isComplete)return{success:!0,message:"Sequence already complete",addedDates:[]};console.log(`üîß [DateManagement] Auto-filling missing dates: ${o.missingDates.join(", ")}`);const s=[],u=[];for(const m of o.missingDates){const n=await this.autoPopulateMissingDate(t,m);u.push(n),n.success&&s.push(m)}const c=u.every(m=>m.success);return{success:c,message:c?`Successfully auto-filled ${s.length} missing dates: ${s.join(", ")}`:`Partially completed: ${s.length}/${o.missingDates.length} dates added`,addedDates:s}}catch(o){return console.error("[DateManagement] Error auto-filling sequence:",o),{success:!1,message:`Error: ${o.message}`,addedDates:[]}}}static getManualInstructions(t){return{steps:["Go to your application and navigate to the ABCD-number page",`Click the "Add Date" button and enter: ${t}`,"Upload an Excel file containing planets data for this date","Add Hour Entry by selecting planets for HR 1-6",'Click "Save" to store the data',"Return to Planets Analysis and test the date"],expectedResult:`Analysis Date: ${new Date(t).toLocaleDateString("en-GB",{day:"2-digit",month:"2-digit",year:"numeric"})}`,note:"After adding the data manually, the Planets Analysis should show the correct date instead of falling back to older dates."}}}class z{static async performRule2Analysis(t,e,o){try{console.log("üöÄ [RealTimeRule2] Starting real-time analysis for:",{userId:t,analysisDate:e,totalDates:o.length});const s=[...o].sort((a,r)=>new Date(a)-new Date(r)),u=s.indexOf(e);if(console.log(`üîç [RealTimeRule2] Looking for analysisDate "${e}" in dates:`,s),console.log(`üìç [RealTimeRule2] Found at index: ${u}`),u===-1)return{success:!1,error:`Analysis date "${e}" not found in available dates: [${s.join(", ")}]. Add this date first or check date formatting.`};let c,m,n,d;if(u<3){if(console.log(`‚ö†Ô∏è [RealTimeRule2] Requested date "${e}" at position ${u+1} doesn't have enough preceding dates`),s.length<4)return{success:!1,error:`Need at least 4 total dates for analysis. Available: ${s.length} dates`};const a=s.length-1;c=s[a],m=s[a-1],n=s[a-2],d=s[a-3],console.log("üîÑ [RealTimeRule2] Using latest complete sequence instead:"),console.log(`   Requested: ${e} (position ${u+1})`),console.log(`   Using: ${c} (position ${a+1})`)}else c=s[u],m=s[u-1],n=s[u-2],d=s[u-3],console.log("‚úÖ [RealTimeRule2] Using requested date sequence:");console.log("üîó [RealTimeRule2] ABCD sequence for analysis:",{aDay:d,bDay:n,cDay:m,dDay:`${c} (analysis source)`});const h=[d,n,m,c],g={};for(const a of h)try{const r=await y.getExcelData(t,a),f=await y.getHourEntry(t,a);g[a]={excel:r,hour:f,success:r&&f},console.log(`üìä [RealTimeRule2] Loaded data for ${a}:`,{hasExcel:!!r,hasHour:!!f})}catch(r){console.error(`‚ùå [RealTimeRule2] Error loading data for ${a}:`,r),g[a]={success:!1,error:r.message}}const b=h.filter(a=>!g[a].success);if(b.length>0){console.log(`‚ö†Ô∏è [RealTimeRule2] Missing data for dates: ${b.join(", ")}`),console.log("üîß [RealTimeRule2] Attempting to auto-populate missing dates...");try{const a=await v.autoFillSequence(t,h);if(console.log("üîß [RealTimeRule2] Auto-fill result:",a),a.success&&a.addedDates.length>0){console.log(`‚úÖ [RealTimeRule2] Successfully auto-populated: ${a.addedDates.join(", ")}`);for(const f of a.addedDates)try{const R=await y.getExcelData(t,f),N=await y.getHourEntry(t,f);g[f]={excel:R,hour:N,success:R&&N},console.log(`‚úÖ [RealTimeRule2] Reloaded data for auto-populated ${f}`)}catch(R){console.error(`‚ùå [RealTimeRule2] Error reloading data for ${f}:`,R),g[f]={success:!1,error:R.message}}const r=h.filter(f=>!g[f].success);if(r.length>0)return{success:!1,error:`Still missing data for dates after auto-population: ${r.join(", ")}. ${v.getManualInstructions(r[0]).steps.slice(0,2).join(". ")}`}}else return{success:!1,error:`Missing data for dates: ${b.join(", ")}. Auto-population failed: ${a.message}. ${v.getManualInstructions(b[0]).steps.slice(0,2).join(". ")}`}}catch(a){return console.error("‚ùå [RealTimeRule2] Auto-fill error:",a),{success:!1,error:`Missing data for dates: ${b.join(", ")}. Auto-population failed. ${v.getManualInstructions(b[0]).steps.slice(0,2).join(". ")}`}}}const A=g[c].hour;if(!(A!=null&&A.planetSelections))return{success:!1,error:`No planet selections found for analysis date ${c}`};const $=Object.keys(A.planetSelections).map(a=>parseInt(a)).sort((a,r)=>a-r);console.log("ü™ê [RealTimeRule2] Available HR periods:",$);const S={};for(const a of $){console.log(`üîç [RealTimeRule2] Analyzing HR ${a}...`);try{const r=await this.performHRAnalysis(a,h,g);S[a]=r,console.log(`‚úÖ [RealTimeRule2] HR ${a} analysis complete:`,{totalTopics:r.topicResults.length,overallABCD:r.overallAbcdNumbers.length,overallBCD:r.overallBcdNumbers.length})}catch(r){console.error(`‚ùå [RealTimeRule2] Error analyzing HR ${a}:`,r),S[a]={error:r.message}}}return{success:!0,data:{analysisDate:e,abcdSequence:{aDay:d,bDay:n,cDay:m,dDay:c},hrResults:S,availableHRs:$,timestamp:new Date().toISOString()}}}catch(s){return console.error("‚ùå [RealTimeRule2] Analysis failed:",s),{success:!1,error:s.message}}}static async performHRAnalysis(t,e,o){var H;const[s,u,c,m]=e,n=(l,i)=>{var M;const D=o[l];if(!D.success)return[];const w=((M=D.excel.data)==null?void 0:M.sets)||D.excel.sets||{},E=(D.hour.planetSelections||{})[t];if(!E||!w[i])return[];const p=new Set,F=w[i];return Object.entries(F).forEach(([C,T])=>{const k=T[E];if(k){const j=this.extractElementNumber(k);j!==null&&p.add(j)}}),Array.from(p).sort((C,T)=>C-T)},d=o[m],h=Object.keys(((H=d.excel.data)==null?void 0:H.sets)||d.excel.sets||{}),g=[],b=new Set,A=new Set,$=new Set,S=new Set;for(const l of h){const i=n(m,l),D=n(c,l),w=n(u,l),x=n(s,l);if(i.length===0){g.push({setName:l,abcdNumbers:[],bcdNumbers:[],dDayCount:0,error:"No D-day numbers found"});continue}const E=U(x,w,D,i,{includeDetailedAnalysis:!1,logResults:!1,setName:l});g.push({setName:l,abcdNumbers:E.abcdNumbers,bcdNumbers:E.bcdNumbers,dDayCount:i.length,summary:E.summary}),i.forEach(p=>b.add(p)),x.forEach(p=>A.add(p)),w.forEach(p=>$.add(p)),D.forEach(p=>S.add(p))}const a=Array.from(b),r=Array.from(A),f=Array.from($),R=Array.from(S),N=a.filter(l=>{let i=0;return r.includes(l)&&i++,f.includes(l)&&i++,R.includes(l)&&i++,i>=2}),B=a.filter(l=>{const i=f.includes(l),D=R.includes(l);return i&&!D||D&&!i}),P=N.sort((l,i)=>l-i),O=B.filter(l=>!N.includes(l)).sort((l,i)=>l-i);return{hrNumber:t,topicResults:g,overallAbcdNumbers:P,overallBcdNumbers:O,totalTopics:g.length,successfulTopics:g.filter(l=>!l.error).length}}static extractElementNumber(t){if(typeof t!="string")return null;const e=t.match(/^[a-z]+-(\d+)[\/\-]/);return e?Number(e[1]):null}static getSimplifiedResults(t){if(!t.success)return{success:!1,error:t.error};const{data:e}=t,o=e.availableHRs[0],s=e.hrResults[o];return!s||s.error?{success:!1,error:(s==null?void 0:s.error)||"No valid HR analysis found"}:{success:!0,data:{analysisDate:e.analysisDate,abcdNumbers:s.overallAbcdNumbers,bcdNumbers:s.overallBcdNumbers,hrNumber:o,source:"realTimeRule2Analysis",timestamp:e.timestamp}}}}export{z as RealTimeRule2AnalysisService};
